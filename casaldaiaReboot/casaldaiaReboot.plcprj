<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<plcProject caseSensitive="true" extendedIdNames="false" useCustomWorkspace="true" debugMode="false" extcheck="true" SFCControl="false" strictPointerCheck="true" verboseWarningMode="true" iecTypeConversionRules="false" PNContactsOnEachNetwork="false" LocalVarsFBAccess="false" strictEnumsCheck="true" copyWarningThreshold="200" version="2.11" useLD2="false" useXPLCFiles="false" useFBMethods="true" customSortOfProjectTree="false" autoDerefPointers="false">
	<image>casaldaiaReboot.imgx</image>
	<commSettings>ModbusTCP:255,1000,M#TCPIP:192.168.1.138/502,5000</commSettings>
	<sources>
		<main>
			<resources>
				<resource name="ELS20" processor="ARM9">
					<task name="Fast" interval="t#1000us" priority="0" type="cyclic" hidden="false" dynamic="false" descr="Fast task"/>
					<task name="Slow" interval="t#10000us" priority="1" type="cyclic" hidden="false" dynamic="false" descr="Slow task"/>
					<task name="Boot" interval="t#0us" priority="2" type="single" hidden="false" dynamic="false" descr="Boot task"/>
					<task name="Back" interval="t#100000us" priority="3" type="cyclic" hidden="false" dynamic="false" descr="Background task"/>
				</resource>
			</resources>
			<tasks>
				<task name="Fast">
					<program>gesVent</program>
				</task>
				<task name="Slow">
					<program>diRd</program>
					<program>aiRd</program>
					<program>logiGen</program>
					<program>mainCycle</program>
					<program>flameStatus</program>
					<program>doWr</program>
					<program>refill</program>
					<program>gesMand</program>
					<program>gesAll</program>
					<program>gesAllIst</program>
				</task>
				<task name="Boot">
					<program>init</program>
				</task>
				<task name="Back">
					<program>gesCom2plc</program>
					<program>tarana</program>
					<program>mbMasterRtu</program>
					<program>ManInit</program>
					<program>bkCalc</program>
					<program>gesCom2hmi</program>
				</task>
			</tasks>
			<globalVars>
				<group name="vOutputs" excludeFromBuild="FALSE" excludeFromBuildIfNotDef="" version="1.0.0">
					<var name="SNuRis255_0h" type="BOOL">
						<address type="Q" typeVar="X" index="255" subIndex="0"/>
					</var>
					<var name="SNuRis255_1h" type="BOOL">
						<address type="Q" typeVar="X" index="255" subIndex="1"/>
					</var>
					<var name="do0h" type="BOOL" dim0="8">
						<descr>Uscite fisiche, array bool</descr>
						<address type="Q" typeVar="X" index="2" subIndex="0"/>
					</var>
					<var name="CTuExtAuger_h" type="BOOL">
						<descr>Contattore comando coclea esterna</descr>
						<address type="Q" typeVar="X" index="2" subIndex="0"/>
					</var>
					<var name="CTuBrnAuger_h" type="BOOL">
						<descr>Contattore coclea bruciatore</descr>
						<address type="Q" typeVar="X" index="2" subIndex="1"/>
					</var>
					<var name="CTuIgnHeatr_h" type="BOOL">
						<descr>Contattore resistenza (candeletta) accensione</descr>
						<address type="Q" typeVar="X" index="2" subIndex="2"/>
					</var>
					<var name="CTuHtngPump_h" type="BOOL">
						<descr>Contattore pompa riscaldamento</descr>
						<address type="Q" typeVar="X" index="2" subIndex="3"/>
					</var>
					<var name="CTuDhwPump_h" type="BOOL">
						<descr>Contattore pompa acqua calda sanitaria</descr>
						<address type="Q" typeVar="X" index="2" subIndex="4"/>
					</var>
					<var name="FCuMixVOpen_h" type="BOOL">
						<descr>Apertura valvola miscelatrice</descr>
						<address type="Q" typeVar="X" index="2" subIndex="5"/>
					</var>
					<var name="FCuMixVClse_h" type="BOOL">
						<descr>Chiusura valvola miscelatrice</descr>
						<address type="Q" typeVar="X" index="2" subIndex="6"/>
					</var>
					<var name="CTuVentCmd_h" type="BOOL">
						<descr>Contattore ventilazione</descr>
						<address type="Q" typeVar="X" index="2" subIndex="7"/>
					</var>
					<var name="do0v" type="BOOL" dim0="8">
						<descr>Uscite virtuali, array bool</descr>
						<address type="M" typeVar="X" index="100" subIndex="3808"/>
					</var>
					<var name="CTuExtAuger_v" type="BOOL">
						<descr>Contattore comando coclea esterna</descr>
						<address type="M" typeVar="X" index="100" subIndex="3808"/>
					</var>
					<var name="CTuBrnAuger_v" type="BOOL">
						<descr>Contattore coclea bruciatore</descr>
						<address type="M" typeVar="X" index="100" subIndex="3809"/>
					</var>
					<var name="CTuIgnHeatr_v" type="BOOL">
						<descr>Contattore resistenza accensione</descr>
						<address type="M" typeVar="X" index="100" subIndex="3810"/>
					</var>
					<var name="CTuHtngPump_v" type="BOOL">
						<descr>Contattore pompa riscaldamento</descr>
						<address type="M" typeVar="X" index="100" subIndex="3811"/>
					</var>
					<var name="CTuDhwPump_v" type="BOOL">
						<descr>Contattore pompa acqua calda sanitaria</descr>
						<address type="M" typeVar="X" index="100" subIndex="3812"/>
					</var>
					<var name="FCuMixVOpen_v" type="BOOL">
						<descr>Apertura valvola miscelatrice</descr>
						<address type="M" typeVar="X" index="100" subIndex="3813"/>
					</var>
					<var name="FCuMixVClse_v" type="BOOL">
						<descr>Chiusura valvola miscelatrice</descr>
						<address type="M" typeVar="X" index="100" subIndex="3814"/>
					</var>
					<var name="CTuVentCmd_v" type="BOOL">
						<descr>Contattore ventilazione</descr>
						<address type="M" typeVar="X" index="100" subIndex="3815"/>
					</var>
					<var name="do0f" type="BOOL" dim0="8">
						<descr>Forzatura valore uscite virtuali, array bool</descr>
						<address type="M" typeVar="X" index="100" subIndex="3816"/>
					</var>
					<var name="CTuExtAuger_f" type="BOOL">
						<descr>Contattore comando coclea esterna</descr>
						<address type="M" typeVar="X" index="100" subIndex="3816"/>
					</var>
					<var name="CTuBrnAuger_f" type="BOOL">
						<descr>Contattore coclea bruciatore</descr>
						<address type="M" typeVar="X" index="100" subIndex="3817"/>
					</var>
					<var name="CTuIgnHeatr_f" type="BOOL">
						<descr>Contattore resistenza accensione</descr>
						<address type="M" typeVar="X" index="100" subIndex="3818"/>
					</var>
					<var name="CTuHtngPump_f" type="BOOL">
						<descr>Contattore pompa riscaldamento</descr>
						<address type="M" typeVar="X" index="100" subIndex="3819"/>
					</var>
					<var name="CTuDhwPump_f" type="BOOL">
						<descr>Contattore pompa acqua calda sanitaria</descr>
						<address type="M" typeVar="X" index="100" subIndex="3820"/>
					</var>
					<var name="FCuMixVOpen_f" type="BOOL">
						<descr>Apertura valvola miscelatrice</descr>
						<address type="M" typeVar="X" index="100" subIndex="3821"/>
					</var>
					<var name="FCuMixVClse_f" type="BOOL">
						<descr>Chiusura valvola miscelatrice</descr>
						<address type="M" typeVar="X" index="100" subIndex="3822"/>
					</var>
					<var name="CTuVentCmd_f" type="BOOL">
						<descr>Contattore ventilazione</descr>
						<address type="M" typeVar="X" index="100" subIndex="3823"/>
					</var>
					<var name="do0m" type="BOOL" dim0="8">
						<descr>Forzatura stato uscite virtuali, array bool</descr>
						<address type="M" typeVar="X" index="100" subIndex="3824"/>
					</var>
					<var name="CTuExtAuger_m" type="BOOL">
						<descr>Contattore comando coclea esterna</descr>
						<address type="M" typeVar="X" index="100" subIndex="3824"/>
					</var>
					<var name="CTuBrnAuger_m" type="BOOL">
						<descr>Contattore coclea bruciatore</descr>
						<address type="M" typeVar="X" index="100" subIndex="3825"/>
					</var>
					<var name="CTuIgnHeatr_m" type="BOOL">
						<descr>Contattore resistenza accensione</descr>
						<address type="M" typeVar="X" index="100" subIndex="3826"/>
					</var>
					<var name="CTuHtngPump_m" type="BOOL">
						<descr>Contattore pompa riscaldamento</descr>
						<address type="M" typeVar="X" index="100" subIndex="3827"/>
					</var>
					<var name="CTuDhwPump_m" type="BOOL">
						<descr>Contattore pompa acqua calda sanitaria</descr>
						<address type="M" typeVar="X" index="100" subIndex="3828"/>
					</var>
					<var name="FCuMixVOpen_m" type="BOOL">
						<descr>Apertura valvola miscelatrice</descr>
						<address type="M" typeVar="X" index="100" subIndex="3829"/>
					</var>
					<var name="FCuMixVClse_m" type="BOOL">
						<descr>Chiusura valvola miscelatrice</descr>
						<address type="M" typeVar="X" index="100" subIndex="3830"/>
					</var>
					<var name="CTuVentCmd_m" type="BOOL">
						<descr>Contattore ventilazione</descr>
						<address type="M" typeVar="X" index="100" subIndex="3831"/>
					</var>
				</group>
				<group name="vInputs" excludeFromBuild="FALSE" excludeFromBuildIfNotDef="" version="1.0.0">
					<var name="di0h" type="BOOL" dim0="24">
						<descr>Ingressi fisici, array bool</descr>
						<address type="I" typeVar="X" index="2" subIndex="0"/>
					</var>
					<var name="SIeTutto_OK_h" type="BOOL">
						<descr>Comandi inseriti</descr>
						<address type="I" typeVar="X" index="2" subIndex="0"/>
					</var>
					<var name="SNePltLevOK_h" type="BOOL">
						<descr>Livello pellet nel bruciatore: OK</descr>
						<address type="I" typeVar="X" index="2" subIndex="1"/>
					</var>
					<var name="TSeOverTemp_h" type="BOOL">
						<descr>Termostato caldaia: sovratemperatura</descr>
						<address type="I" typeVar="X" index="2" subIndex="2"/>
					</var>
					<var name="SNeBurnConn_h" type="BOOL">
						<descr>Bruciatore connesso</descr>
						<address type="I" typeVar="X" index="2" subIndex="3"/>
					</var>
					<var name="FCeValvOpen_h" type="BOOL">
						<descr>Valvola aperta</descr>
						<address type="I" typeVar="X" index="2" subIndex="4"/>
					</var>
					<var name="FCeValvClos_h" type="BOOL">
						<descr>Valvola chiusa</descr>
						<address type="I" typeVar="X" index="2" subIndex="5"/>
					</var>
					<var name="SNeSpare_6_h" type="BOOL">
						<descr>Riserva e6</descr>
						<address type="I" typeVar="X" index="2" subIndex="6"/>
					</var>
					<var name="SNeSpare_7_h" type="BOOL">
						<descr>Riserva e7</descr>
						<address type="I" typeVar="X" index="2" subIndex="7"/>
					</var>
					<var name="SNeSpare_8_h" type="BOOL">
						<descr>Riserva e8</descr>
						<address type="I" typeVar="X" index="2" subIndex="8"/>
					</var>
					<var name="SNeSpare_9_h" type="BOOL">
						<descr>Riserva e9</descr>
						<address type="I" typeVar="X" index="2" subIndex="9"/>
					</var>
					<var name="SNeSpare_10_h" type="BOOL">
						<descr>Riserva e10</descr>
						<address type="I" typeVar="X" index="2" subIndex="10"/>
					</var>
					<var name="SNeSpare_11_h" type="BOOL">
						<descr>Riserva e11</descr>
						<address type="I" typeVar="X" index="2" subIndex="11"/>
					</var>
					<var name="SNeSpare_12_h" type="BOOL">
						<descr>Riserva e12</descr>
						<address type="I" typeVar="X" index="2" subIndex="12"/>
					</var>
					<var name="SNeSpare_13_h" type="BOOL">
						<descr>Riserva e13</descr>
						<address type="I" typeVar="X" index="2" subIndex="13"/>
					</var>
					<var name="SNeSpare_14_h" type="BOOL">
						<descr>Riserva e14</descr>
						<address type="I" typeVar="X" index="2" subIndex="14"/>
					</var>
					<var name="SNeSpare_15_h" type="BOOL">
						<descr>Riserva e15</descr>
						<address type="I" typeVar="X" index="2" subIndex="15"/>
					</var>
					<var name="SNeSpare_16_h" type="BOOL">
						<descr>Riserva e16</descr>
						<address type="I" typeVar="X" index="2" subIndex="16"/>
					</var>
					<var name="SNeSpare_17_h" type="BOOL">
						<descr>Riserva e17</descr>
						<address type="I" typeVar="X" index="2" subIndex="17"/>
					</var>
					<var name="SNeSpare_18_h" type="BOOL">
						<descr>Riserva e18</descr>
						<address type="I" typeVar="X" index="2" subIndex="18"/>
					</var>
					<var name="SNeSpare_19_h" type="BOOL">
						<descr>Riserva e19</descr>
						<address type="I" typeVar="X" index="2" subIndex="19"/>
					</var>
					<var name="SNeSpare_20_h" type="BOOL">
						<descr>Riserva e20</descr>
						<address type="I" typeVar="X" index="2" subIndex="20"/>
					</var>
					<var name="SNeSpare_21_h" type="BOOL">
						<descr>Riserva e21</descr>
						<address type="I" typeVar="X" index="2" subIndex="21"/>
					</var>
					<var name="SNeSpare_22_h" type="BOOL">
						<descr>Riserva e22</descr>
						<address type="I" typeVar="X" index="2" subIndex="22"/>
					</var>
					<var name="SNeSpare_23_h" type="BOOL">
						<descr>Riserva e23</descr>
						<address type="I" typeVar="X" index="2" subIndex="23"/>
					</var>
					<var name="di0v" type="BOOL" dim0="24">
						<descr>Ingressi virtuali, array bool</descr>
						<address type="M" typeVar="X" index="100" subIndex="3900"/>
					</var>
					<var name="SIeTutto_OK_v" type="BOOL">
						<descr>Comandi inseriti</descr>
						<address type="M" typeVar="X" index="100" subIndex="3900"/>
					</var>
					<var name="SNePltLevOK_v" type="BOOL">
						<descr>Livello pellet nel bruciatore: OK</descr>
						<address type="M" typeVar="X" index="100" subIndex="3901"/>
					</var>
					<var name="TSeOverTemp_v" type="BOOL">
						<descr>Termostato caldaia: sovratemperatura</descr>
						<address type="M" typeVar="X" index="100" subIndex="3902"/>
					</var>
					<var name="SNeBurnConn_v" type="BOOL">
						<descr>Bruciatore connesso</descr>
						<address type="M" typeVar="X" index="100" subIndex="3903"/>
					</var>
					<var name="FCeValvOpen_v" type="BOOL">
						<descr>Valvola aperta</descr>
						<address type="M" typeVar="X" index="100" subIndex="3904"/>
					</var>
					<var name="FCeValvClos_v" type="BOOL">
						<descr>Valvola chiusa</descr>
						<address type="M" typeVar="X" index="100" subIndex="3905"/>
					</var>
					<var name="SNeSpare_6_v" type="BOOL">
						<descr>Riserva e6</descr>
						<address type="M" typeVar="X" index="100" subIndex="3906"/>
					</var>
					<var name="SNeSpare_7_v" type="BOOL">
						<descr>Riserva e7</descr>
						<address type="M" typeVar="X" index="100" subIndex="3907"/>
					</var>
					<var name="SNeSpare_8_v" type="BOOL">
						<descr>Riserva e8</descr>
						<address type="M" typeVar="X" index="100" subIndex="3908"/>
					</var>
					<var name="SNeSpare_9_v" type="BOOL">
						<descr>Riserva e9</descr>
						<address type="M" typeVar="X" index="100" subIndex="3909"/>
					</var>
					<var name="SNeSpare_10_v" type="BOOL">
						<descr>Riserva e10</descr>
						<address type="M" typeVar="X" index="100" subIndex="3910"/>
					</var>
					<var name="SNeSpare_11_v" type="BOOL">
						<descr>Riserva e11</descr>
						<address type="M" typeVar="X" index="100" subIndex="3911"/>
					</var>
					<var name="SNeSpare_12_v" type="BOOL">
						<descr>Riserva e12</descr>
						<address type="M" typeVar="X" index="100" subIndex="3912"/>
					</var>
					<var name="SNeSpare_13_v" type="BOOL">
						<descr>Riserva e13</descr>
						<address type="M" typeVar="X" index="100" subIndex="3913"/>
					</var>
					<var name="SNeSpare_14_v" type="BOOL">
						<descr>Riserva e14</descr>
						<address type="M" typeVar="X" index="100" subIndex="3914"/>
					</var>
					<var name="SNeSpare_15_v" type="BOOL">
						<descr>Riserva e15</descr>
						<address type="M" typeVar="X" index="100" subIndex="3915"/>
					</var>
					<var name="SNeSpare_16_v" type="BOOL">
						<descr>Riserva e16</descr>
						<address type="M" typeVar="X" index="100" subIndex="3916"/>
					</var>
					<var name="SNeSpare_17_v" type="BOOL">
						<descr>Riserva e17</descr>
						<address type="M" typeVar="X" index="100" subIndex="3917"/>
					</var>
					<var name="SNeSpare_18_v" type="BOOL">
						<descr>Riserva e18</descr>
						<address type="M" typeVar="X" index="100" subIndex="3918"/>
					</var>
					<var name="SNeSpare_19_v" type="BOOL">
						<descr>Riserva e19</descr>
						<address type="M" typeVar="X" index="100" subIndex="3919"/>
					</var>
					<var name="SNeSpare_20_v" type="BOOL">
						<descr>Riserva e20</descr>
						<address type="M" typeVar="X" index="100" subIndex="3920"/>
					</var>
					<var name="SNeSpare_21_v" type="BOOL">
						<descr>Riserva e21</descr>
						<address type="M" typeVar="X" index="100" subIndex="3921"/>
					</var>
					<var name="SNeSpare_22_v" type="BOOL">
						<descr>Riserva e22</descr>
						<address type="M" typeVar="X" index="100" subIndex="3922"/>
					</var>
					<var name="SNeSpare_23_v" type="BOOL">
						<descr>Riserva e23</descr>
						<address type="M" typeVar="X" index="100" subIndex="3923"/>
					</var>
					<var name="di0f" type="BOOL" dim0="24">
						<descr>Forzatura valore ingressi virtuali, array bool</descr>
						<address type="M" typeVar="X" index="100" subIndex="3924"/>
					</var>
					<var name="SIeTutto_OK_f" type="BOOL">
						<descr>Comandi inseriti</descr>
						<address type="M" typeVar="X" index="100" subIndex="3924"/>
					</var>
					<var name="SNePltLevOK_f" type="BOOL">
						<descr>Livello pellet nel bruciatore: OK</descr>
						<address type="M" typeVar="X" index="100" subIndex="3925"/>
					</var>
					<var name="TSeOverTemp_f" type="BOOL">
						<descr>Termostato caldaia: sovratemperatura</descr>
						<address type="M" typeVar="X" index="100" subIndex="3926"/>
					</var>
					<var name="SNeBurnConn_f" type="BOOL">
						<descr>Bruciatore connesso</descr>
						<address type="M" typeVar="X" index="100" subIndex="3927"/>
					</var>
					<var name="FCeValvOpen_f" type="BOOL">
						<descr>Valvola aperta</descr>
						<address type="M" typeVar="X" index="100" subIndex="3928"/>
					</var>
					<var name="FCeValvClos_f" type="BOOL">
						<descr>Valvola chiusa</descr>
						<address type="M" typeVar="X" index="100" subIndex="3929"/>
					</var>
					<var name="SNeSpare_6_f" type="BOOL">
						<descr>Riserva e6</descr>
						<address type="M" typeVar="X" index="100" subIndex="3930"/>
					</var>
					<var name="SNeSpare_7_f" type="BOOL">
						<descr>Riserva e7</descr>
						<address type="M" typeVar="X" index="100" subIndex="3931"/>
					</var>
					<var name="SNeSpare_8_f" type="BOOL">
						<descr>Riserva e8</descr>
						<address type="M" typeVar="X" index="100" subIndex="3932"/>
					</var>
					<var name="SNeSpare_9_f" type="BOOL">
						<descr>Riserva e9</descr>
						<address type="M" typeVar="X" index="100" subIndex="3933"/>
					</var>
					<var name="SNeSpare_10_f" type="BOOL">
						<descr>Riserva e10</descr>
						<address type="M" typeVar="X" index="100" subIndex="3934"/>
					</var>
					<var name="SNeSpare_11_f" type="BOOL">
						<descr>Riserva e11</descr>
						<address type="M" typeVar="X" index="100" subIndex="3935"/>
					</var>
					<var name="SNeSpare_12_f" type="BOOL">
						<descr>Riserva e12</descr>
						<address type="M" typeVar="X" index="100" subIndex="3936"/>
					</var>
					<var name="SNeSpare_13_f" type="BOOL">
						<descr>Riserva e13</descr>
						<address type="M" typeVar="X" index="100" subIndex="3937"/>
					</var>
					<var name="SNeSpare_14_f" type="BOOL">
						<descr>Riserva e14</descr>
						<address type="M" typeVar="X" index="100" subIndex="3938"/>
					</var>
					<var name="SNeSpare_15_f" type="BOOL">
						<descr>Riserva e15</descr>
						<address type="M" typeVar="X" index="100" subIndex="3939"/>
					</var>
					<var name="SNeSpare_16_f" type="BOOL">
						<descr>Riserva e16</descr>
						<address type="M" typeVar="X" index="100" subIndex="3940"/>
					</var>
					<var name="SNeSpare_17_f" type="BOOL">
						<descr>Riserva e17</descr>
						<address type="M" typeVar="X" index="100" subIndex="3941"/>
					</var>
					<var name="SNeSpare_18_f" type="BOOL">
						<descr>Riserva e18</descr>
						<address type="M" typeVar="X" index="100" subIndex="3942"/>
					</var>
					<var name="SNeSpare_19_f" type="BOOL">
						<descr>Riserva e19</descr>
						<address type="M" typeVar="X" index="100" subIndex="3943"/>
					</var>
					<var name="SNeSpare_20_f" type="BOOL">
						<descr>Riserva e20</descr>
						<address type="M" typeVar="X" index="100" subIndex="3944"/>
					</var>
					<var name="SNeSpare_21_f" type="BOOL">
						<descr>Riserva e21</descr>
						<address type="M" typeVar="X" index="100" subIndex="3945"/>
					</var>
					<var name="SNeSpare_22_f" type="BOOL">
						<descr>Riserva e22</descr>
						<address type="M" typeVar="X" index="100" subIndex="3946"/>
					</var>
					<var name="SNeSpare_23_f" type="BOOL">
						<descr>Riserva e23</descr>
						<address type="M" typeVar="X" index="100" subIndex="3947"/>
					</var>
					<var name="di0m" type="BOOL" dim0="24">
						<descr>Forzatura stato ingressi virtuali, array bool</descr>
						<address type="M" typeVar="X" index="100" subIndex="3948"/>
					</var>
					<var name="SIeTutto_OK_m" type="BOOL">
						<descr>Comandi inseriti</descr>
						<address type="M" typeVar="X" index="100" subIndex="3948"/>
					</var>
					<var name="SNePltLevOK_m" type="BOOL">
						<descr>Livello pellet nel bruciatore: OK</descr>
						<address type="M" typeVar="X" index="100" subIndex="3949"/>
					</var>
					<var name="TSeOverTemp_m" type="BOOL">
						<descr>Termostato caldaia: sovratemperatura</descr>
						<address type="M" typeVar="X" index="100" subIndex="3950"/>
					</var>
					<var name="SNeBurnConn_m" type="BOOL">
						<descr>Bruciatore connesso</descr>
						<address type="M" typeVar="X" index="100" subIndex="3951"/>
					</var>
					<var name="FCeValvOpen_m" type="BOOL">
						<descr>Valvola aperta</descr>
						<address type="M" typeVar="X" index="100" subIndex="3952"/>
					</var>
					<var name="FCeValvClos_m" type="BOOL">
						<descr>Valvola chiusa</descr>
						<address type="M" typeVar="X" index="100" subIndex="3953"/>
					</var>
					<var name="SNeSpare_6_m" type="BOOL">
						<descr>Riserva e6</descr>
						<address type="M" typeVar="X" index="100" subIndex="3954"/>
					</var>
					<var name="SNeSpare_7_m" type="BOOL">
						<descr>Riserva e7</descr>
						<address type="M" typeVar="X" index="100" subIndex="3955"/>
					</var>
					<var name="SNeSpare_8_m" type="BOOL">
						<descr>Riserva e8</descr>
						<address type="M" typeVar="X" index="100" subIndex="3956"/>
					</var>
					<var name="SNeSpare_9_m" type="BOOL">
						<descr>Riserva e9</descr>
						<address type="M" typeVar="X" index="100" subIndex="3957"/>
					</var>
					<var name="SNeSpare_10_m" type="BOOL">
						<descr>Riserva e10</descr>
						<address type="M" typeVar="X" index="100" subIndex="3958"/>
					</var>
					<var name="SNeSpare_11_m" type="BOOL">
						<descr>Riserva e11</descr>
						<address type="M" typeVar="X" index="100" subIndex="3959"/>
					</var>
					<var name="SNeSpare_12_m" type="BOOL">
						<descr>Riserva e12</descr>
						<address type="M" typeVar="X" index="100" subIndex="3960"/>
					</var>
					<var name="SNeSpare_13_m" type="BOOL">
						<descr>Riserva e13</descr>
						<address type="M" typeVar="X" index="100" subIndex="3961"/>
					</var>
					<var name="SNeSpare_14_m" type="BOOL">
						<descr>Riserva e14</descr>
						<address type="M" typeVar="X" index="100" subIndex="3962"/>
					</var>
					<var name="SNeSpare_15_m" type="BOOL">
						<descr>Riserva e15</descr>
						<address type="M" typeVar="X" index="100" subIndex="3963"/>
					</var>
					<var name="SNeSpare_16_m" type="BOOL">
						<descr>Riserva e16</descr>
						<address type="M" typeVar="X" index="100" subIndex="3964"/>
					</var>
					<var name="SNeSpare_17_m" type="BOOL">
						<descr>Riserva e17</descr>
						<address type="M" typeVar="X" index="100" subIndex="3965"/>
					</var>
					<var name="SNeSpare_18_m" type="BOOL">
						<descr>Riserva e18</descr>
						<address type="M" typeVar="X" index="100" subIndex="3966"/>
					</var>
					<var name="SNeSpare_19_m" type="BOOL">
						<descr>Riserva e19</descr>
						<address type="M" typeVar="X" index="100" subIndex="3967"/>
					</var>
					<var name="SNeSpare_20_m" type="BOOL">
						<descr>Riserva e20</descr>
						<address type="M" typeVar="X" index="100" subIndex="3968"/>
					</var>
					<var name="SNeSpare_21_m" type="BOOL">
						<descr>Riserva e21</descr>
						<address type="M" typeVar="X" index="100" subIndex="3969"/>
					</var>
					<var name="SNeSpare_22_m" type="BOOL">
						<descr>Riserva e22</descr>
						<address type="M" typeVar="X" index="100" subIndex="3970"/>
					</var>
					<var name="SNeSpare_23_m" type="BOOL">
						<descr>Riserva e23</descr>
						<address type="M" typeVar="X" index="100" subIndex="3971"/>
					</var>
					<var name="appWeSeq" type="UDINT">
						<descr>Ingressi virtuali, array bool</descr>
						<address type="M" typeVar="X" index="100" subIndex="3972"/>
					</var>
					<var name="appWeh" type="UDINT">
						<descr>appoggio intermedio dei bool in virt</descr>
						<address type="M" typeVar="X" index="100" subIndex="3976"/>
					</var>
				</group>
				<group name="vRt2hmi" excludeFromBuild="FALSE" excludeFromBuildIfNotDef="" version="1.0.0">
					<var name="TmTimeStamp" type="UDINT">
						<address type="M" typeVar="W" index="100" subIndex="200"/>
					</var>
					<var name="diImg" type="UDINT">
						<descr>immagine input per hmi</descr>
						<address type="M" typeVar="W" index="100" subIndex="204"/>
					</var>
					<var name="doImg" type="UDINT">
						<descr>immagine output per hmi</descr>
						<address type="M" typeVar="W" index="100" subIndex="208"/>
					</var>
					<var name="pvTCaldaia" type="INT">
						<address type="M" typeVar="W" index="100" subIndex="212"/>
					</var>
					<var name="pvTFumi" type="INT">
						<address type="M" typeVar="W" index="100" subIndex="214"/>
					</var>
					<var name="pvTMandata" type="INT">
						<address type="M" typeVar="W" index="100" subIndex="216"/>
					</var>
					<var name="pvTRitorno" type="INT">
						<address type="M" typeVar="W" index="100" subIndex="218"/>
					</var>
					<var name="pvTEsterna" type="INT">
						<address type="M" typeVar="W" index="100" subIndex="220"/>
					</var>
					<var name="pvTInterna" type="INT">
						<address type="M" typeVar="W" index="100" subIndex="222"/>
					</var>
					<var name="pvTAriaComb" type="INT">
						<address type="M" typeVar="W" index="100" subIndex="224"/>
					</var>
					<var name="pvTCaldaia2" type="INT">
						<address type="M" typeVar="W" index="100" subIndex="226"/>
					</var>
					<var name="pvPFiamma" type="INT">
						<address type="M" typeVar="W" index="100" subIndex="228"/>
					</var>
					<var name="phMaCy" type="UINT">
						<address type="M" typeVar="W" index="100" subIndex="230"/>
					</var>
					<var name="phMaCyT" type="UINT">
						<address type="M" typeVar="W" index="100" subIndex="232"/>
					</var>
					<var name="phFlSt" type="UINT">
						<address type="M" typeVar="W" index="100" subIndex="234"/>
					</var>
					<var name="phFlStT" type="UINT">
						<address type="M" typeVar="W" index="100" subIndex="236"/>
					</var>
					<var name="phCari" type="UINT">
						<address type="M" typeVar="W" index="100" subIndex="238"/>
					</var>
					<var name="phCariT" type="UINT">
						<address type="M" typeVar="W" index="100" subIndex="240"/>
					</var>
					<var name="phRefi" type="UINT">
						<address type="M" typeVar="W" index="100" subIndex="242"/>
					</var>
					<var name="phRefiT" type="UINT">
						<address type="M" typeVar="W" index="100" subIndex="244"/>
					</var>
					<var name="phGeMa" type="UINT">
						<address type="M" typeVar="W" index="100" subIndex="246"/>
					</var>
					<var name="phGeMaT" type="UINT">
						<address type="M" typeVar="W" index="100" subIndex="248"/>
					</var>
					<var name="ventDuty" type="UINT">
						<address type="M" typeVar="W" index="100" subIndex="250"/>
					</var>
					<var name="PellDuty" type="UINT">
						<address type="M" typeVar="W" index="100" subIndex="252"/>
					</var>
					<var name="alarms" type="DINT">
						<descr>allarmi</descr>
						<address type="M" typeVar="W" index="100" subIndex="256"/>
					</var>
					<var name="alarms0" type="INT">
						<descr>allarmi</descr>
						<address type="M" typeVar="W" index="100" subIndex="256"/>
					</var>
					<var name="SIaTUTTONOK" type="BOOL">
						<descr>Allarme ausiliari non inseriti</descr>
						<address type="M" typeVar="W" index="100" subIndex="256" bitIndex="0"/>
					</var>
					<var name="TTaSOC_TH1_" type="BOOL">
						<descr>Allarme sonda in corto alta 1</descr>
						<address type="M" typeVar="W" index="100" subIndex="256" bitIndex="1"/>
					</var>
					<var name="alarms1" type="INT">
						<descr>allarmi</descr>
						<address type="M" typeVar="W" index="100" subIndex="258"/>
					</var>
					<var name="PTaPGASFAIL" type="BOOL">
						<descr>Allarme trasd. press. gas</descr>
						<address type="M" typeVar="W" index="100" subIndex="258" bitIndex="0"/>
					</var>
					<var name="mbCnNAvviamen" type="UDINT">
						<descr>contatore avviamenti</descr>
						<address type="M" typeVar="X" index="100" subIndex="260"/>
					</var>
					<var name="mbCnNCariEste" type="UDINT">
						<descr>contatore caricamenti esterni</descr>
						<address type="M" typeVar="X" index="100" subIndex="264"/>
					</var>
					<var name="mbCnNCariBruc" type="UDINT">
						<descr>contatore caricamenti bruciatore</descr>
						<address type="M" typeVar="X" index="100" subIndex="268"/>
					</var>
					<var name="mbCnMFunz" type="UDINT" dim0="3">
						<descr>contatore funzionamento minimo</descr>
						<address type="M" typeVar="X" index="100" subIndex="272"/>
					</var>
					<var name="mbCnMFunzMini" type="UDINT">
						<descr>contatore funzionamento minimo</descr>
						<address type="M" typeVar="X" index="100" subIndex="272"/>
					</var>
					<var name="mbCnMFunzMedi" type="UDINT">
						<descr>contatore funzionamento medio</descr>
						<address type="M" typeVar="X" index="100" subIndex="276"/>
					</var>
					<var name="mbCnMFunzMaxi" type="UDINT">
						<descr>contatore funzionamento massimo</descr>
						<address type="M" typeVar="X" index="100" subIndex="280"/>
					</var>
				</group>
				<group name="vGlobal" excludeFromBuild="FALSE" excludeFromBuildIfNotDef="" version="1.0.0">
					<var name="b" type="t_cenTerm"/>
					<var name="aiCh" type="t_aiCh" dim0="11"/>
					<var name="WHRegs" type="WORD" dim0="16">
						<descr>Holding registers (Write)</descr>
					</var>
					<var name="RHRegs" type="WORD" dim0="2" dim1="4">
						<descr>Holding registers (Read)</descr>
						<address type="M" typeVar="W" index="100" subIndex="800"/>
					</var>
					<var name="RHRegsInt" type="INT" dim0="16">
						<address type="M" typeVar="W" index="100" subIndex="800"/>
					</var>
				</group>
				<group name="vRt2plc" excludeFromBuild="FALSE" excludeFromBuildIfNotDef="" version="1.0.0">
					<var name="diImgFf" type="UDINT">
						<descr>valore forzatura input</descr>
						<address type="M" typeVar="W" index="100" subIndex="400"/>
					</var>
					<var name="diImgFm" type="UDINT">
						<descr>stato forzatura input</descr>
						<address type="M" typeVar="W" index="100" subIndex="404"/>
					</var>
					<var name="doImgFf" type="UDINT">
						<descr>valore forzatura output</descr>
						<address type="M" typeVar="W" index="100" subIndex="408"/>
					</var>
					<var name="doImgFm" type="UDINT">
						<descr>stato forzatura output</descr>
						<address type="M" typeVar="W" index="100" subIndex="412"/>
					</var>
					<var name="doImgV" type="UDINT">
						<descr>proposta output</descr>
						<address type="M" typeVar="W" index="100" subIndex="416"/>
					</var>
					<var name="TS2plc_sec" type="UDINT">
						<descr>ora UTC in secondi</descr>
						<address type="M" typeVar="W" index="100" subIndex="432"/>
					</var>
					<var name="wDog2plc" type="UINT">
						<descr>watch dog dal server al PLC</descr>
						<address type="M" typeVar="W" index="100" subIndex="436"/>
					</var>
				</group>
				<group name="_vEmulator" excludeFromBuild="FALSE" excludeFromBuildIfNotDef="" version="1.0.0">
					<var name="null" type="BOOL"/>
				</group>
			</globalVars>
			<retainVars>
				<group name="vRt2plc" excludeFromBuild="FALSE" excludeFromBuildIfNotDef="" version="1.0.0">
					<var name="spTAlWOvert_dC" type="UINT">
						<descr>sp surrisc warning dC</descr>
						<address type="M" typeVar="X" index="100" subIndex="440"/>
					</var>
					<var name="spTAlAOvert_dC" type="UINT">
						<descr>sp surrisc allarme dC</descr>
						<address type="M" typeVar="X" index="100" subIndex="442"/>
					</var>
					<var name="spTmVent_s" type="UINT">
						<descr>sp ritardo spegn. ventilazione sec.</descr>
						<address type="M" typeVar="X" index="100" subIndex="444"/>
					</var>
					<var name="xpTLock_dC" type="UINT">
						<descr>sp temp blocco scarica dC</descr>
						<address type="M" typeVar="X" index="100" subIndex="446"/>
					</var>
					<var name="spTmWdog_mS" type="UINT">
						<descr>sp tempo insens. watchDog com mS</descr>
						<address type="M" typeVar="X" index="100" subIndex="448"/>
					</var>
					<var name="spTBomSP_dC" type="UINT">
						<descr>sp temp. gas (bombola) dC</descr>
						<address type="M" typeVar="X" index="100" subIndex="450"/>
					</var>
					<var name="spTBomP_d" type="UINT">
						<descr>sp P bombola dec.</descr>
						<address type="M" typeVar="X" index="100" subIndex="452"/>
					</var>
					<var name="spTBomI_c" type="UINT">
						<descr>sp I bombola cent.</descr>
						<address type="M" typeVar="X" index="100" subIndex="454"/>
					</var>
					<var name="spTBomD_c" type="UINT">
						<descr>sp D bombola cent.</descr>
						<address type="M" typeVar="X" index="100" subIndex="456"/>
					</var>
					<var name="spTRisSP_dC" type="UINT">
						<descr>sp fs sovratemp riscald. dC</descr>
						<address type="M" typeVar="X" index="100" subIndex="458"/>
					</var>
					<var name="spTRisP_d" type="UINT">
						<descr>sp P riscald. dec.</descr>
						<address type="M" typeVar="X" index="100" subIndex="460"/>
					</var>
					<var name="spTRisI_c" type="UINT">
						<descr>sp I riscald. cent.</descr>
						<address type="M" typeVar="X" index="100" subIndex="462"/>
					</var>
					<var name="spTRisD_c" type="UINT">
						<descr>sp D riscald. cent.</descr>
						<address type="M" typeVar="X" index="100" subIndex="464"/>
					</var>
					<var name="spQCar_dg" type="UINT">
						<descr>sp grammi da caricare (td) dg</descr>
						<address type="M" typeVar="X" index="100" subIndex="466"/>
					</var>
					<var name="spNUtil468" type="UINT">
						<descr>sp durata imp. fisso erogazione mS</descr>
						<address type="M" typeVar="X" index="100" subIndex="468"/>
					</var>
					<var name="spTSoc_dC" type="UINT">
						<descr>sp temper. variaz. minima nel tempo, dC</descr>
						<address type="M" typeVar="X" index="100" subIndex="470"/>
					</var>
					<var name="spTmSoc_s" type="UINT">
						<descr>sp tempo analisi cambio temper., Sec</descr>
						<address type="M" typeVar="X" index="100" subIndex="472"/>
					</var>
					<var name="spDtBt_dC" type="UINT">
						<descr>sp dT max tra sonde risc/bomb dC</descr>
						<address type="M" typeVar="X" index="100" subIndex="474"/>
					</var>
					<var name="spDpBtBp_dB" type="UINT">
						<descr>sp Dt misurata e teorica f(P) dB</descr>
						<address type="M" typeVar="X" index="100" subIndex="476"/>
					</var>
					<var name="spQRiserva_g" type="UINT">
						<descr>####################################</descr>
						<address type="M" typeVar="X" index="100" subIndex="478"/>
					</var>
					<var name="aiCfg" type="t_tara" dim0="10">
						<descr>200 bytes</descr>
						<address type="M" typeVar="X" index="100" subIndex="2048"/>
					</var>
					<var name="spTCariFred_s" type="UINT">
						<descr>sp tempo caric. pellet per acc. fredda</descr>
						<address type="M" typeVar="X" index="100" subIndex="2248"/>
					</var>
					<var name="spTRiVeIgni_s" type="UINT">
						<descr>sp tempo ritardo ventilazione e ignitore</descr>
						<address type="M" typeVar="X" index="100" subIndex="2250"/>
					</var>
					<var name="spQVentIgni_pc" type="UINT">
						<descr>sp portata ventilazione in accensione</descr>
						<address type="M" typeVar="X" index="100" subIndex="2252"/>
					</var>
					<var name="spQVentInBu_pc" type="UINT">
						<descr>sp ventilazione iniziale propagazione fiamma</descr>
						<address type="M" typeVar="X" index="100" subIndex="2254"/>
					</var>
					<var name="spTVentIdle_s" type="UINT">
						<descr>sp tempo vent. prep. idle focolare</descr>
						<address type="M" typeVar="X" index="100" subIndex="2256"/>
					</var>
					<var name="spQIdleBurn_pc" type="UINT">
						<descr>sp ventilazione in fase di messa a riposo</descr>
						<address type="M" typeVar="X" index="100" subIndex="2258"/>
					</var>
					<var name="spTCariRipr_s" type="UINT">
						<descr>sp tempo caric. pellet per ripresa focolare</descr>
						<address type="M" typeVar="X" index="100" subIndex="2260"/>
					</var>
					<var name="spTVentRipr_s" type="UINT">
						<descr>sp tempo ventilazione per ripresa focolare</descr>
						<address type="M" typeVar="X" index="100" subIndex="2262"/>
					</var>
					<var name="spQVentRipr_pc" type="UINT">
						<descr>sp portata ventilazione per ripresa focolare</descr>
						<address type="M" typeVar="X" index="100" subIndex="2264"/>
					</var>
					<var name="spTPeriCocl_ds" type="UINT">
						<descr>sp tempo periodo PWM coclea</descr>
						<address type="M" typeVar="X" index="100" subIndex="2266"/>
					</var>
					<var name="spTToutFiam_s" type="UINT">
						<descr>sp tempo timeout manc. fiamma</descr>
						<address type="M" typeVar="X" index="100" subIndex="2268"/>
					</var>
					<var name="spTMancAcce_s" type="UINT">
						<descr>sp tempo timeout manc. accensione</descr>
						<address type="M" typeVar="X" index="100" subIndex="2270"/>
					</var>
					<var name="spTVentAcce_s" type="UINT">
						<descr>sp tempo preventilazione accensione</descr>
						<address type="M" typeVar="X" index="100" subIndex="2272"/>
					</var>
					<var name="spTPropFiam_s" type="UINT">
						<descr>sp tempo pausa propagazione fiamma</descr>
						<address type="M" typeVar="X" index="100" subIndex="2274"/>
					</var>
					<var name="spTFunzMinI_s" type="UINT">
						<descr>sp tempo funz. al minimo prima di run pieno</descr>
						<address type="M" typeVar="X" index="100" subIndex="2276"/>
					</var>
					<var name="spTVeSpInTe_s" type="UINT">
						<descr>sp tempo vent. per spegn se in temperatura</descr>
						<address type="M" typeVar="X" index="100" subIndex="2278"/>
					</var>
					<var name="spTVentPuli_s" type="UINT">
						<descr>sp tempo pausa ventilazione di pulizia</descr>
						<address type="M" typeVar="X" index="100" subIndex="2280"/>
					</var>
					<var name="spQVentPuli_pc" type="UINT">
						<descr>sp portata ventilazione durante pulizia</descr>
						<address type="M" typeVar="X" index="100" subIndex="2282"/>
					</var>
					<var name="spTDuraPuli_s" type="UINT">
						<descr>sp tempo durata ventilazione di pulizia</descr>
						<address type="M" typeVar="X" index="100" subIndex="2284"/>
					</var>
					<var name="spTDuraLava_ds" type="UINT">
						<descr>sp tempo durata lavaggio per sovratemp</descr>
						<address type="M" typeVar="X" index="100" subIndex="2286"/>
					</var>
					<var name="spTCariCExt_s" type="UINT">
						<descr>sp tempo carico coclea esterna</descr>
						<address type="M" typeVar="X" index="100" subIndex="2288"/>
					</var>
					<var name="spKTempCald_dC" type="UINT">
						<descr>sp temperatura caldaia</descr>
						<address type="M" typeVar="X" index="100" subIndex="2290"/>
					</var>
					<var name="spKIsteCald_dK" type="UINT">
						<descr>sp isteresi ripartenza bruciatore</descr>
						<address type="M" typeVar="X" index="100" subIndex="2292"/>
					</var>
					<var name="spKLavTCald_dC" type="UINT">
						<descr>sp temperatura lavaggio caldaia (pompa riscald.)</descr>
						<address type="M" typeVar="X" index="100" subIndex="2294"/>
					</var>
					<var name="spKMaxTCald_dC" type="UINT">
						<descr>sp temperatura massima caldaia</descr>
						<address type="M" typeVar="X" index="100" subIndex="2296"/>
					</var>
					<var name="spKMaxTFumi_dC" type="UINT">
						<descr>sp temperatura max fumi</descr>
						<address type="M" typeVar="X" index="100" subIndex="2298"/>
					</var>
					<var name="spKMinTFumi_dC" type="UINT">
						<descr>sp temperatura minima fumi in funzionamento</descr>
						<address type="M" typeVar="X" index="100" subIndex="2300"/>
					</var>
					<var name="spKMxDeTCal_dK" type="UINT">
						<descr>sp delta T max tra sonde caldaia</descr>
						<address type="M" typeVar="X" index="100" subIndex="2302"/>
					</var>
					<var name="spKMinTMand_dC" type="UINT">
						<descr>sp temperatura minima mandata (climatica)</descr>
						<address type="M" typeVar="X" index="100" subIndex="2304"/>
					</var>
					<var name="spKMaxTMand_dC" type="UINT">
						<descr>sp temperatura massima mandata (climatica)</descr>
						<address type="M" typeVar="X" index="100" subIndex="2306"/>
					</var>
					<var name="spKMaxTExtr_dC" type="UINT">
						<descr>sp temperatura minima esterna (climatica)</descr>
						<address type="M" typeVar="X" index="100" subIndex="2308"/>
					</var>
					<var name="spKMinTExtr_dC" type="UINT">
						<descr>sp temperatura massima esterna (climatica)</descr>
						<address type="M" typeVar="X" index="100" subIndex="2310"/>
					</var>
					<var name="spKFsErInte_dK" type="UINT">
						<descr>sp temperatura errore reg. interna</descr>
						<address type="M" typeVar="X" index="100" subIndex="2312"/>
					</var>
					<var name="spKFsCorMan_dK" type="UINT">
						<descr>sp temperatura fondo scala correzione mandata</descr>
						<address type="M" typeVar="X" index="100" subIndex="2314"/>
					</var>
					<var name="spRPresFiam_pm" type="UINT">
						<descr>sp perc. radiaz. pres. fiamma</descr>
						<address type="M" typeVar="X" index="100" subIndex="2316"/>
					</var>
					<var name="spKCampRidu_dk" type="UINT">
						<descr>sp campo riduzione potenza</descr>
						<address type="M" typeVar="X" index="100" subIndex="2318"/>
					</var>
					<var name="regPars" type="UINT" dim0="5" dim1="2">
						<address type="M" typeVar="X" index="100" subIndex="2320"/>
					</var>
					<var name="spTMandRisc_dC" type="UINT">
						<descr>sp temperatura mandata riscaldamento</descr>
						<address type="M" typeVar="X" index="100" subIndex="2340"/>
					</var>
					<var name="spTVentInBu_pc" type="UINT">
						<descr>sp tempo accensione ventilata iniziale</descr>
						<address type="M" typeVar="X" index="100" subIndex="2342"/>
					</var>
					<var name="spKMaxErrMa_cK" type="UINT">
						<descr>sp tempo accensione ventilata iniziale</descr>
						<address type="M" typeVar="X" index="100" subIndex="2344"/>
					</var>
					<var name="spTHtngPmp_dC" type="UINT">
						<descr>####################################</descr>
						<address type="M" typeVar="X" index="100" subIndex="2346"/>
					</var>
					<var name="spTDhwPump_dC" type="UINT">
						<descr>####################################</descr>
						<address type="M" typeVar="X" index="100" subIndex="2348"/>
					</var>
					<var name="cnNAvviamen" type="UDINT">
						<descr>contatore avviamenti</descr>
						<address type="M" typeVar="X" index="100" subIndex="2376"/>
					</var>
					<var name="cnNCariEste" type="UDINT">
						<descr>contatore caricamenti esterni</descr>
						<address type="M" typeVar="X" index="100" subIndex="2380"/>
					</var>
					<var name="cnNCariBruc" type="UDINT">
						<descr>contatore caricamenti bruciatore</descr>
						<address type="M" typeVar="X" index="100" subIndex="2384"/>
					</var>
					<var name="cnMFunzMini" type="UDINT">
						<descr>contatore funzionamento minimo</descr>
						<address type="M" typeVar="X" index="100" subIndex="2388"/>
					</var>
					<var name="cnMFunzMedi" type="UDINT">
						<descr>contatore funzionamento medio</descr>
						<address type="M" typeVar="X" index="100" subIndex="2392"/>
					</var>
					<var name="cnMFunzMaxi" type="UDINT">
						<descr>contatore funzionamento massimo</descr>
						<address type="M" typeVar="X" index="100" subIndex="2396"/>
					</var>
					<var name="cmd0" type="WORD">
						<descr>comandi operativi</descr>
						<address type="M" typeVar="W" index="100" subIndex="2402"/>
					</var>
					<var name="cmdReset" type="BOOL">
						<descr>comando reset</descr>
						<address type="M" typeVar="W" index="100" subIndex="2400" bitIndex="0"/>
					</var>
					<var name="cmdRstAl" type="BOOL">
						<descr>comando reset allarmi</descr>
						<address type="M" typeVar="W" index="100" subIndex="2400" bitIndex="3"/>
					</var>
					<var name="cmdRiserva" type="BOOL">
						<descr>era gas sel. R1234yf</descr>
						<address type="M" typeVar="W" index="100" subIndex="2400" bitIndex="5"/>
					</var>
					<var name="cmdAbort" type="BOOL">
						<descr>cmdRiserva 8</descr>
						<address type="M" typeVar="W" index="100" subIndex="2400" bitIndex="8"/>
					</var>
					<var name="cmd0_B" type="BOOL">
						<descr>cmdRiserva 11</descr>
						<address type="M" typeVar="W" index="100" subIndex="2400" bitIndex="11"/>
					</var>
					<var name="cmd0_C" type="BOOL">
						<descr>cmdRiserva 12</descr>
						<address type="M" typeVar="W" index="100" subIndex="2400" bitIndex="12"/>
					</var>
					<var name="cmd0_D" type="BOOL">
						<descr>cmdRiserva 13</descr>
						<address type="M" typeVar="W" index="100" subIndex="2400" bitIndex="13"/>
					</var>
					<var name="cmd0_E" type="BOOL">
						<descr>cmdRiserva 14</descr>
						<address type="M" typeVar="W" index="100" subIndex="2400" bitIndex="14"/>
					</var>
					<var name="cmd0_F" type="BOOL">
						<descr>cmdRiserva 15</descr>
						<address type="M" typeVar="W" index="100" subIndex="2400" bitIndex="15"/>
					</var>
					<var name="cmd1" type="WORD">
						<descr>comandi operativi</descr>
						<address type="M" typeVar="W" index="100" subIndex="2402"/>
					</var>
					<var name="cmd1_0" type="BOOL">
						<descr>cmdRiserva 9</descr>
						<address type="M" typeVar="W" index="100" subIndex="2402" bitIndex="0"/>
					</var>
					<var name="cmd1_1" type="BOOL">
						<descr>cmdRiserva 9</descr>
						<address type="M" typeVar="W" index="100" subIndex="2402" bitIndex="1"/>
					</var>
					<var name="cmd1_2" type="BOOL">
						<descr>cmdRiserva 9</descr>
						<address type="M" typeVar="W" index="100" subIndex="2402" bitIndex="2"/>
					</var>
					<var name="cmd1_3" type="BOOL">
						<descr>cmdRiserva 9</descr>
						<address type="M" typeVar="W" index="100" subIndex="2402" bitIndex="3"/>
					</var>
					<var name="cmd1_4" type="BOOL">
						<descr>cmdRiserva 9</descr>
						<address type="M" typeVar="W" index="100" subIndex="2402" bitIndex="4"/>
					</var>
					<var name="cmd1_5" type="BOOL">
						<descr>cmdRiserva 9</descr>
						<address type="M" typeVar="W" index="100" subIndex="2402" bitIndex="5"/>
					</var>
					<var name="cmd1_6" type="BOOL">
						<descr>cmdRiserva 9</descr>
						<address type="M" typeVar="W" index="100" subIndex="2402" bitIndex="6"/>
					</var>
					<var name="cmd1_7" type="BOOL">
						<descr>cmdRiserva 9</descr>
						<address type="M" typeVar="W" index="100" subIndex="2402" bitIndex="7"/>
					</var>
					<var name="cmd1_8" type="BOOL">
						<descr>cmdRiserva 9</descr>
						<address type="M" typeVar="W" index="100" subIndex="2402" bitIndex="8"/>
					</var>
					<var name="cmd1_9" type="BOOL">
						<descr>cmdRiserva 9</descr>
						<address type="M" typeVar="W" index="100" subIndex="2402" bitIndex="9"/>
					</var>
					<var name="cmd1_A" type="BOOL">
						<descr>cmdRiserva 10</descr>
						<address type="M" typeVar="W" index="100" subIndex="2402" bitIndex="10"/>
					</var>
					<var name="cmd1_B" type="BOOL">
						<descr>cmdRiserva 11</descr>
						<address type="M" typeVar="W" index="100" subIndex="2402" bitIndex="11"/>
					</var>
					<var name="cmd1_C" type="BOOL">
						<descr>cmdRiserva 12</descr>
						<address type="M" typeVar="W" index="100" subIndex="2402" bitIndex="12"/>
					</var>
					<var name="cmd1_D" type="BOOL">
						<descr>cmdRiserva 13</descr>
						<address type="M" typeVar="W" index="100" subIndex="2402" bitIndex="13"/>
					</var>
					<var name="cmd1_E" type="BOOL">
						<descr>cmdRiserva 14</descr>
						<address type="M" typeVar="W" index="100" subIndex="2402" bitIndex="14"/>
					</var>
					<var name="cmd1_F" type="BOOL">
						<descr>cmdRiserva 15</descr>
						<address type="M" typeVar="W" index="100" subIndex="2402" bitIndex="15"/>
					</var>
				</group>
			</retainVars>
			<constantVars>
				<group name="kAi" excludeFromBuild="FALSE" excludeFromBuildIfNotDef="" version="1.0.0">
					<const name="tCaldaia" type="INT">
						<initValue>0</initValue>
					</const>
					<const name="tFumi" type="INT">
						<initValue>1</initValue>
					</const>
					<const name="tMandata" type="INT">
						<initValue>2</initValue>
					</const>
					<const name="tRitorno" type="INT">
						<initValue>3</initValue>
					</const>
					<const name="tEsterna" type="INT">
						<initValue>4</initValue>
					</const>
					<const name="tInterna" type="INT">
						<initValue>5</initValue>
					</const>
					<const name="tAriaComb" type="INT">
						<initValue>6</initValue>
					</const>
					<const name="tCaldaia2" type="INT">
						<initValue>7</initValue>
					</const>
					<const name="rFiamma" type="INT">
						<initValue>8</initValue>
					</const>
					<const name="r9" type="INT">
						<initValue>9</initValue>
					</const>
					<const name="lastCh" type="INT">
						<initValue>9</initValue>
					</const>
				</group>
				<group name="kAlm" excludeFromBuild="FALSE" excludeFromBuildIfNotDef="" version="1.0.0">
					<const name="alCfg" type="BYTE" dim0="32">
						<initValue>[
	16#09,
	16#0E,
	16#0E,
	16#0E,
	16#0E,
	16#0E,
	16#06,
	16#0E,
	16#0E,
	16#0E,
	16#00,
	16#0F,
	16#00,
	16#00,
	16#0F,
	16#0F,
	16#0E,
	16#0E,
	16#0E,
	16#0F,
	16#0F,
	16#0F,
	16#0F,
	16#00,
	16#0F,
	16#0F,
	16#0E,
	16#0F,
	16#00,
	16#00,
	16#00,
	16#00
]</initValue>
					</const>
					<const name="alRit" type="INT" dim0="32">
						<initValue>[
	10, 
	1000, 
	1000, 
	1000, 
	1000, 
	1000, 
	1000, 
	1000, 
	1000, 
	1000, 
	10000, 
	100, 
	100, 
	1000, 
	100, 
	100,
	1000,		
	1000,
	1000,
	1000,
	2000,
	2000,
	100,
	1000,
	100,
	1000,
	1000,
	100,
	0,
	0,
	0,
	0
]</initValue>
					</const>
				</group>
				<group name="kPhMainCycle" excludeFromBuild="FALSE" excludeFromBuildIfNotDef="" version="1.0.0">
					<const name="mcNotRdy" type="INT">
						<descr>Attesa approntamento</descr>
						<initValue>0</initValue>
					</const>
					<const name="mcCmdWait" type="INT">
						<descr>Attesa comandi</descr>
						<initValue>5</initValue>
					</const>
					<const name="mcInitLoad" type="INT">
						<descr>Caricamento iniziale</descr>
						<initValue>10</initValue>
					</const>
					<const name="mcFlameWait" type="INT">
						<descr>Attesa segnale rilevatore fiamma</descr>
						<initValue>15</initValue>
					</const>
					<const name="mcInitBurn" type="INT">
						<descr>Combustione iniziale</descr>
						<initValue>20</initValue>
					</const>
					<const name="mcNoVentIgn" type="INT">
						<descr>Propagazione fiamma s/ventilazione</descr>
						<initValue>25</initValue>
					</const>
					<const name="mcVentRstrt" type="INT">
						<descr>Ripresa ventilazione</descr>
						<initValue>30</initValue>
					</const>
					<const name="mcPwrSel" type="INT">
						<descr>Selezione livello potenza</descr>
						<initValue>35</initValue>
					</const>
					<const name="mcPrsStabBurn" type="INT">
						<descr>Accesso diretto alla combustione stabile</descr>
						<initValue>40</initValue>
					</const>
					<const name="mcStableBurn" type="INT">
						<descr>Combustione stabile</descr>
						<initValue>45</initValue>
					</const>
					<const name="mcAshRemoval" type="INT">
						<descr>Rimozione periodica cenere</descr>
						<initValue>50</initValue>
					</const>
					<const name="mcIdleFire" type="INT">
						<descr>Mantenimento statico fiamma (in temperatura)</descr>
						<initValue>55</initValue>
					</const>
					<const name="mcBurnResume" type="INT">
						<descr>Ripresa fiamma dopo idlefire</descr>
						<initValue>60</initValue>
					</const>
					<const name="mcVentStart" type="INT">
						<descr>Avvio ventilazione per ripresa</descr>
						<initValue>65</initValue>
					</const>
					<const name="mcPelletFeed" type="INT">
						<descr>Alimentazione pellet per ripristino</descr>
						<initValue>70</initValue>
					</const>
					<const name="mcVentHold" type="INT">
						<descr>Mantenimento ventilazione</descr>
						<initValue>75</initValue>
					</const>
					<const name="mcIdleReturn" type="INT">
						<descr>Ritorno alla quiete</descr>
						<initValue>80</initValue>
					</const>
					<const name="mcANotRdy" type="INT">
						<descr>Anomalia da attesa iniziale</descr>
						<initValue>100</initValue>
					</const>
					<const name="mcACmdWait" type="INT">
						<descr>Anomalia da attesa comando</descr>
						<initValue>105</initValue>
					</const>
					<const name="mcAInitLoad" type="INT">
						<descr>Anomalia da caricamento iniziale</descr>
						<initValue>110</initValue>
					</const>
					<const name="mcAFlameWait" type="INT">
						<descr>Anomalia da attesa rilevatore fiamma</descr>
						<initValue>115</initValue>
					</const>
					<const name="mcAInitBurn" type="INT">
						<descr>Anomalia da combustione iniziale</descr>
						<initValue>120</initValue>
					</const>
					<const name="mcANoVentIgn" type="INT">
						<descr>Anomalia da propagazione fiamma s/ventilazione</descr>
						<initValue>125</initValue>
					</const>
					<const name="mcAVentRstrt" type="INT">
						<descr>Anomalia da ripresa ventilazione</descr>
						<initValue>130</initValue>
					</const>
					<const name="mcAPwrSel" type="INT">
						<descr>Anomalia da selezione livello potenza</descr>
						<initValue>135</initValue>
					</const>
					<const name="mcAPrsStabBurn" type="INT">
						<descr>Anomalia da accesso diretto alla combustione stabile</descr>
						<initValue>140</initValue>
					</const>
					<const name="mcAStableBurn" type="INT">
						<descr>Anomalia da combustione stabile</descr>
						<initValue>145</initValue>
					</const>
					<const name="mcAAshRemoval" type="INT">
						<descr>Anomalia da rimozione periodica cenere</descr>
						<initValue>150</initValue>
					</const>
					<const name="mcAIdleFire" type="INT">
						<descr>Anomalia da mantenimento statico fiamma</descr>
						<initValue>155</initValue>
					</const>
					<const name="mcABurnResume" type="INT">
						<descr>Anomalia da ripresa fiamma</descr>
						<initValue>160</initValue>
					</const>
					<const name="mcAVentStart" type="INT">
						<descr>Anomalia da avvio ventilazione</descr>
						<initValue>165</initValue>
					</const>
					<const name="mcAPelletFeed" type="INT">
						<descr>Anomalia da alimentazione pellet</descr>
						<initValue>170</initValue>
					</const>
					<const name="mcAVentHold" type="INT">
						<descr>Anomalia da mantenimento ventilazione</descr>
						<initValue>175</initValue>
					</const>
					<const name="mcAIdleReturn" type="INT">
						<descr>Anomalia da ritorno alla quiete</descr>
						<initValue>180</initValue>
					</const>
					<const name="mcAResTot" type="INT">
						<descr>Anomalia generale totale</descr>
						<initValue>185</initValue>
					</const>
					<const name="mcAnomRec" type="INT">
						<descr>Stato di recupero anomalie</descr>
						<initValue>200</initValue>
					</const>
				</group>
				<group name="kPhFlameStatus" excludeFromBuild="FALSE" excludeFromBuildIfNotDef="" version="1.0.0">
					<const name="fsFlameOff" type="INT">
						<descr>Fiamma spenta</descr>
						<initValue>0</initValue>
					</const>
					<const name="fsPreIgnition" type="INT">
						<descr>Preparazione accensione</descr>
						<initValue>1</initValue>
					</const>
					<const name="fsIgniting" type="INT">
						<descr>Accensione</descr>
						<initValue>2</initValue>
					</const>
					<const name="fsFlameStable" type="INT">
						<descr>Fiamma stabile</descr>
						<initValue>3</initValue>
					</const>
					<const name="fsFlameLow" type="INT">
						<descr>Fiamma debole</descr>
						<initValue>4</initValue>
					</const>
					<const name="fsFlameRecovery" type="INT">
						<descr>Tentativo ripresa fiamma</descr>
						<initValue>5</initValue>
					</const>
					<const name="fsTempCheck" type="INT">
						<descr>Controllo temperatura braciere</descr>
						<initValue>6</initValue>
					</const>
					<const name="fsPostIgnition" type="INT">
						<descr>Post accensione</descr>
						<initValue>7</initValue>
					</const>
					<const name="fsFlameOutCheck" type="INT">
						<descr>Verifica spegnimento fiamma</descr>
						<initValue>8</initValue>
					</const>
					<const name="fsCoolingDown" type="INT">
						<descr>Raffreddamento braciere</descr>
						<initValue>9</initValue>
					</const>
					<const name="fsAFlameOff" type="INT">
						<descr>Anomalia fiamma spenta</descr>
						<initValue>100</initValue>
					</const>
					<const name="fsAPreIgnition" type="INT">
						<descr>Anomalia preparazione accensione</descr>
						<initValue>101</initValue>
					</const>
					<const name="fsAIgniting" type="INT">
						<descr>Anomalia accensione</descr>
						<initValue>102</initValue>
					</const>
					<const name="fsAFlameStable" type="INT">
						<descr>Anomalia fiamma stabile</descr>
						<initValue>103</initValue>
					</const>
					<const name="fsAFlameLow" type="INT">
						<descr>Anomalia fiamma debole</descr>
						<initValue>104</initValue>
					</const>
					<const name="fsAFlameRecovery" type="INT">
						<descr>Anomalia tentativo ripresa fiamma</descr>
						<initValue>105</initValue>
					</const>
					<const name="fsATempCheck" type="INT">
						<descr>Anomalia controllo temperatura braciere</descr>
						<initValue>106</initValue>
					</const>
					<const name="fsAPostIgnition" type="INT">
						<descr>Anomalia post accensione</descr>
						<initValue>107</initValue>
					</const>
					<const name="fsAFlameOutCheck" type="INT">
						<descr>Anomalia verifica spegnimento fiamma</descr>
						<initValue>108</initValue>
					</const>
					<const name="fsACoolingDown" type="INT">
						<descr>Anomalia raffreddamento braciere</descr>
						<initValue>109</initValue>
					</const>
					<const name="fsAResTot" type="INT">
						<descr>Anomalia generale totale</descr>
						<initValue>118</initValue>
					</const>
					<const name="fsAnomRec" type="INT">
						<descr>Stato di recupero anomalie</descr>
						<initValue>200</initValue>
					</const>
				</group>
				<group name="kPhCaricoP" excludeFromBuild="FALSE" excludeFromBuildIfNotDef="" version="1.0.0">
					<const name="cpNotRdy" type="INT">
						<descr>Attesa approntamento</descr>
						<initValue>0</initValue>
					</const>
					<const name="cpPause" type="INT">
						<descr>Pausa carico</descr>
						<initValue>5</initValue>
					</const>
					<const name="cpLoad" type="INT">
						<descr>Caricamento attivo</descr>
						<initValue>10</initValue>
					</const>
					<const name="cpLoop" type="INT">
						<descr>Riciclo</descr>
						<initValue>15</initValue>
					</const>
					<const name="cpInitBurn" type="INT">
						<initValue>20</initValue>
					</const>
					<const name="cpNoVentIgn" type="INT">
						<initValue>25</initValue>
					</const>
					<const name="cpVentRstrt" type="INT">
						<initValue>30</initValue>
					</const>
					<const name="cpPwrSel" type="INT">
						<initValue>35</initValue>
					</const>
					<const name="cpStableBurn" type="INT">
						<initValue>40</initValue>
					</const>
					<const name="cpAshRemoval" type="INT">
						<initValue>45</initValue>
					</const>
					<const name="cpIdleFire" type="INT">
						<initValue>50</initValue>
					</const>
					<const name="cpBurnResume" type="INT">
						<initValue>55</initValue>
					</const>
					<const name="cpVentStart" type="INT">
						<initValue>60</initValue>
					</const>
					<const name="cpPelletFeed" type="INT">
						<initValue>65</initValue>
					</const>
					<const name="cpVentHold" type="INT">
						<initValue>70</initValue>
					</const>
					<const name="cpIdleReturn" type="INT">
						<initValue>75</initValue>
					</const>
					<const name="cpANotRdy" type="INT">
						<descr>Anomalia da Attesa approntamento</descr>
						<initValue>100</initValue>
					</const>
					<const name="cpAPause" type="INT">
						<descr>Anomalia da Pausa carico</descr>
						<initValue>105</initValue>
					</const>
					<const name="cpALoad" type="INT">
						<descr>Anomalia da Caricamento attivo</descr>
						<initValue>110</initValue>
					</const>
					<const name="cpALoop" type="INT">
						<descr>Anomalia da Riciclo</descr>
						<initValue>115</initValue>
					</const>
					<const name="cpAInitBurn" type="INT">
						<descr>Anomalia da</descr>
						<initValue>120</initValue>
					</const>
					<const name="cpANoVentIgn" type="INT">
						<descr>Anomalia da</descr>
						<initValue>125</initValue>
					</const>
					<const name="cpAVentRstrt" type="INT">
						<descr>Anomalia da</descr>
						<initValue>130</initValue>
					</const>
					<const name="cpAPwrSel" type="INT">
						<descr>Anomalia da</descr>
						<initValue>135</initValue>
					</const>
					<const name="cpAStableBurn" type="INT">
						<descr>Anomalia da</descr>
						<initValue>140</initValue>
					</const>
					<const name="cpAAshRemoval" type="INT">
						<descr>Anomalia da</descr>
						<initValue>145</initValue>
					</const>
					<const name="cpAIdleFire" type="INT">
						<descr>Anomalia da</descr>
						<initValue>150</initValue>
					</const>
					<const name="cpABurnResume" type="INT">
						<descr>Anomalia da</descr>
						<initValue>155</initValue>
					</const>
					<const name="cpAVentStart" type="INT">
						<descr>Anomalia da</descr>
						<initValue>160</initValue>
					</const>
					<const name="cpAPelletFeed" type="INT">
						<descr>Anomalia da</descr>
						<initValue>165</initValue>
					</const>
					<const name="cpAVentHold" type="INT">
						<descr>Anomalia da</descr>
						<initValue>170</initValue>
					</const>
					<const name="cpAIdleReturn" type="INT">
						<descr>Anomalia da</descr>
						<initValue>175</initValue>
					</const>
					<const name="cpAResTot" type="INT">
						<descr>Anomalia generale totale</descr>
						<initValue>180</initValue>
					</const>
					<const name="cpAnomRec" type="INT">
						<descr>Stato di recupero anomalie</descr>
						<initValue>200</initValue>
					</const>
				</group>
				<group name="kPhRefill" excludeFromBuild="FALSE" excludeFromBuildIfNotDef="" version="1.0.0">
					<const name="rfNotRdy" type="INT">
						<descr>Attesa approntamento</descr>
						<initValue>0</initValue>
					</const>
					<const name="rfWaitEmpt" type="INT">
						<descr>Attesa richiesta rifornimento</descr>
						<initValue>10</initValue>
					</const>
					<const name="rfChekEmpt" type="INT">
						<descr>Verifica reale mancanza pellet</descr>
						<initValue>20</initValue>
					</const>
					<const name="rfLoad" type="INT">
						<descr>Caricamento attivo</descr>
						<initValue>30</initValue>
					</const>
					<const name="rfCkFull" type="INT">
						<descr>Controllo rifornimento avvenuto</descr>
						<initValue>40</initValue>
					</const>
					<const name="rfCkNoPlt" type="INT">
						<descr>Controllo che davvero sia fallito il carico</descr>
						<initValue>50</initValue>
					</const>
					<const name="rfLoop" type="INT">
						<descr>Ricicla</descr>
						<initValue>60</initValue>
					</const>
					<const name="rfANotRdy" type="INT">
						<descr>Anomalia da Attesa approntamento</descr>
						<initValue>100</initValue>
					</const>
					<const name="rfAWaitEmpt" type="INT">
						<descr>Anomalia da Attesa richiesta rifornimento</descr>
						<initValue>110</initValue>
					</const>
					<const name="rfAChekEmpt" type="INT">
						<descr>Anomalia da Verifica reale mancanza pellet</descr>
						<initValue>120</initValue>
					</const>
					<const name="rfALoad" type="INT">
						<descr>Anomalia da Caricamento attivo</descr>
						<initValue>130</initValue>
					</const>
					<const name="rfACkFull" type="INT">
						<descr>Anomalia da Controllo rifornimento avvenuto</descr>
						<initValue>140</initValue>
					</const>
					<const name="rfACkNoPlt" type="INT">
						<descr>Anomalia da Controllo che davvero sia fallito il carico</descr>
						<initValue>150</initValue>
					</const>
					<const name="rfALoop" type="INT">
						<descr>Anomalia da Ricicla</descr>
						<initValue>160</initValue>
					</const>
					<const name="rfAResTot" type="INT">
						<descr>Anomalia generale totale</descr>
						<initValue>200</initValue>
					</const>
					<const name="rfAnomRec" type="INT">
						<descr>Stato di recupero anomalie</descr>
						<initValue>210</initValue>
					</const>
				</group>
				<group name="kPhGesMand" excludeFromBuild="FALSE" excludeFromBuildIfNotDef="" version="1.0.0">
					<const name="mgNotRdy" type="INT">
						<descr>Attesa approntamento</descr>
						<initValue>0</initValue>
					</const>
					<const name="mgCmdWait" type="INT">
						<descr>Attesa comandi</descr>
						<initValue>5</initValue>
					</const>
					<const name="mgTempEval" type="INT">
						<descr>Caricamento iniziale</descr>
						<initValue>10</initValue>
					</const>
					<const name="mgClosProp" type="INT">
						<descr>Attesa segnale rilevatore fiamma</descr>
						<initValue>15</initValue>
					</const>
					<const name="mgOpenProp" type="INT">
						<descr>Combustione iniziale</descr>
						<initValue>20</initValue>
					</const>
					<const name="mgLoopBack" type="INT">
						<descr>Propagazione fiamma s/ventilazione</descr>
						<initValue>25</initValue>
					</const>
					<const name="mgANotRdy" type="INT">
						<descr>Anomalia da attesa iniziale</descr>
						<initValue>100</initValue>
					</const>
					<const name="mgACmdWait" type="INT">
						<descr>Anomalia da attesa comando</descr>
						<initValue>105</initValue>
					</const>
					<const name="mgATempEval" type="INT">
						<descr>Anomalia da caricamento iniziale</descr>
						<initValue>110</initValue>
					</const>
					<const name="mgAClosProp" type="INT">
						<descr>Anomalia da attesa rilevatore fiamma</descr>
						<initValue>115</initValue>
					</const>
					<const name="mgAOpenProp" type="INT">
						<descr>Anomalia da combustione iniziale</descr>
						<initValue>120</initValue>
					</const>
					<const name="mgALoopBack" type="INT">
						<descr>Anomalia da propagazione fiamma s/ventilazione</descr>
						<initValue>125</initValue>
					</const>
					<const name="mgAResTot" type="INT">
						<descr>Anomalia generale totale</descr>
						<initValue>180</initValue>
					</const>
					<const name="mgAnomRec" type="INT">
						<descr>Stato di recupero anomalie</descr>
						<initValue>200</initValue>
					</const>
				</group>
			</constantVars>
			<iecVarsDeclaration>
				<group name="vOutputs">
					<iecDeclaration active="TRUE" valid="TRUE">
						<![CDATA[VAR_GLOBAL
	SNuRis255_0h AT %QX255.0 : BOOL;
	SNuRis255_1h AT %QX255.1 : BOOL;

	do0h AT %QX2.0 : ARRAY[0..7] OF BOOL;	(* Uscite fisiche, array bool *)
	CTuExtAuger_h 	AT %QX2.0 : BOOL;		(* Contattore comando coclea esterna *)
	CTuBrnAuger_h 	AT %QX2.1 : BOOL;		(* Contattore coclea bruciatore *)
	CTuIgnHeatr_h 	AT %QX2.2 : BOOL;		(* Contattore resistenza (candeletta) accensione *)
	CTuHtngPump_h 	AT %QX2.3 : BOOL;		(* Contattore pompa riscaldamento *)
	CTuDhwPump_h 		AT %QX2.4 : BOOL;		(* Contattore pompa acqua calda sanitaria *)
	FCuMixVOpen_h 	AT %QX2.5 : BOOL;		(* Apertura valvola miscelatrice *)
	FCuMixVClse_h 	AT %QX2.6 : BOOL;		(* Chiusura valvola miscelatrice *)
	CTuVentCmd_h 		AT %QX2.7 : BOOL;		(* Contattore ventilazione *)

	do0v AT %MX100.3808 : ARRAY[0..7] OF BOOL;	(* Uscite virtuali, array bool *)
	CTuExtAuger_v 	AT %MX100.3808 : BOOL;	(* Contattore comando coclea esterna *)
	CTuBrnAuger_v 	AT %MX100.3809 : BOOL;	(* Contattore coclea bruciatore *)
	CTuIgnHeatr_v 	AT %MX100.3810 : BOOL;	(* Contattore resistenza accensione *)
	CTuHtngPump_v 	AT %MX100.3811 : BOOL;	(* Contattore pompa riscaldamento *)
	CTuDhwPump_v 		AT %MX100.3812 : BOOL;	(* Contattore pompa acqua calda sanitaria *)
	FCuMixVOpen_v 	AT %MX100.3813 : BOOL;	(* Apertura valvola miscelatrice *)
	FCuMixVClse_v 	AT %MX100.3814 : BOOL;	(* Chiusura valvola miscelatrice *)
	CTuVentCmd_v 		AT %MX100.3815 : BOOL;	(* Contattore ventilazione *)

	do0f AT %MX100.3816 : ARRAY[0..7] OF BOOL;	(* Forzatura valore uscite virtuali, array bool *)
	CTuExtAuger_f 	AT %MX100.3816 : BOOL;	(* Contattore comando coclea esterna *)
	CTuBrnAuger_f 	AT %MX100.3817 : BOOL;	(* Contattore coclea bruciatore *)
	CTuIgnHeatr_f 	AT %MX100.3818 : BOOL;	(* Contattore resistenza accensione *)
	CTuHtngPump_f 	AT %MX100.3819 : BOOL;	(* Contattore pompa riscaldamento *)
	CTuDhwPump_f 		AT %MX100.3820 : BOOL;	(* Contattore pompa acqua calda sanitaria *)
	FCuMixVOpen_f 	AT %MX100.3821 : BOOL;	(* Apertura valvola miscelatrice *)
	FCuMixVClse_f 	AT %MX100.3822 : BOOL;	(* Chiusura valvola miscelatrice *)
	CTuVentCmd_f 		AT %MX100.3823 : BOOL;	(* Contattore ventilazione *)

	do0m AT %MX100.3824 : ARRAY[0..7] OF BOOL;	(* Forzatura stato uscite virtuali, array bool *)
	CTuExtAuger_m 	AT %MX100.3824 : BOOL;	(* Contattore comando coclea esterna *)
	CTuBrnAuger_m 	AT %MX100.3825 : BOOL;	(* Contattore coclea bruciatore *)
	CTuIgnHeatr_m 	AT %MX100.3826 : BOOL;	(* Contattore resistenza accensione *)
	CTuHtngPump_m 	AT %MX100.3827 : BOOL;	(* Contattore pompa riscaldamento *)
	CTuDhwPump_m 		AT %MX100.3828 : BOOL;	(* Contattore pompa acqua calda sanitaria *)
	FCuMixVOpen_m 	AT %MX100.3829 : BOOL;	(* Apertura valvola miscelatrice *)
	FCuMixVClse_m 	AT %MX100.3830 : BOOL;	(* Chiusura valvola miscelatrice *)
	CTuVentCmd_m 		AT %MX100.3831 : BOOL;	(* Contattore ventilazione *)

//	appWuSeq AT %MX100.3872 : UDINT;	(* Uscite virtuali, array bool *)
//	appWuv AT %MX100.3876 : UDINT;	(* appoggio intermedio dei bool out virt *)
//	appWuh AT %MX100.3880 : UDINT;	(* appoggio intermedio dei bool out virt *)
END_VAR

]]>
					</iecDeclaration>
				</group>
				<group name="vInputs">
					<iecDeclaration active="TRUE" valid="TRUE">
						<![CDATA[VAR_GLOBAL
	di0h AT %IX2.0 : ARRAY[0..23] OF BOOL;	(* Ingressi fisici, array bool *)
	SIeTutto_OK_h 	AT %IX2.0 : BOOL;		(* Comandi inseriti *)
	SNePltLevOK_h 	AT %IX2.1 : BOOL;		(* Livello pellet nel bruciatore: OK *)
	TSeOverTemp_h 	AT %IX2.2 : BOOL;		(* Termostato caldaia: sovratemperatura *)
	SNeBurnConn_h 	AT %IX2.3 : BOOL;		(* Bruciatore connesso *)
	FCeValvOpen_h 	AT %IX2.4 : BOOL;		(* Valvola aperta *)
	FCeValvClos_h 	AT %IX2.5 : BOOL;		(* Valvola chiusa *)
	SNeSpare_6_h    AT %IX2.6 : BOOL;		(* Riserva e6 *)
	SNeSpare_7_h    AT %IX2.7 : BOOL;		(* Riserva e7 *)
	SNeSpare_8_h    AT %IX2.8 : BOOL;		(* Riserva e8 *)
	SNeSpare_9_h    AT %IX2.9 : BOOL;		(* Riserva e9 *)
	SNeSpare_10_h   AT %IX2.10 : BOOL;		(* Riserva e10 *)
	SNeSpare_11_h   AT %IX2.11 : BOOL;		(* Riserva e11 *)
	SNeSpare_12_h   AT %IX2.12 : BOOL;		(* Riserva e12 *)
	SNeSpare_13_h   AT %IX2.13 : BOOL;		(* Riserva e13 *)
	SNeSpare_14_h   AT %IX2.14 : BOOL;		(* Riserva e14 *)
	SNeSpare_15_h   AT %IX2.15 : BOOL;		(* Riserva e15 *)
	SNeSpare_16_h   AT %IX2.16 : BOOL;		(* Riserva e16 *)
	SNeSpare_17_h   AT %IX2.17 : BOOL;		(* Riserva e17 *)
	SNeSpare_18_h   AT %IX2.18 : BOOL;		(* Riserva e18 *)
	SNeSpare_19_h   AT %IX2.19 : BOOL;		(* Riserva e19 *)
	SNeSpare_20_h   AT %IX2.20 : BOOL;		(* Riserva e20 *)
	SNeSpare_21_h   AT %IX2.21 : BOOL;		(* Riserva e21 *)
	SNeSpare_22_h   AT %IX2.22 : BOOL;		(* Riserva e22 *)
	SNeSpare_23_h   AT %IX2.23 : BOOL;		(* Riserva e23 *)
	
	di0v AT %MX100.3900 : ARRAY[0..23] OF BOOL;	(* Ingressi virtuali, array bool *)
	SIeTutto_OK_v 	AT %MX100.3900 : BOOL;	(* Comandi inseriti *)
	SNePltLevOK_v 	AT %MX100.3901 : BOOL;	(* Livello pellet nel bruciatore: OK *)
	TSeOverTemp_v 	AT %MX100.3902 : BOOL;	(* Termostato caldaia: sovratemperatura *)
	SNeBurnConn_v 	AT %MX100.3903 : BOOL;	(* Bruciatore connesso *)
	FCeValvOpen_v 	AT %MX100.3904 : BOOL;	(* Valvola aperta *)
	FCeValvClos_v 	AT %MX100.3905 : BOOL;	(* Valvola chiusa *)
	SNeSpare_6_v    AT %MX100.3906 : BOOL;	(* Riserva e6 *)
	SNeSpare_7_v    AT %MX100.3907 : BOOL;	(* Riserva e7 *)
	SNeSpare_8_v    AT %MX100.3908 : BOOL;	(* Riserva e8 *)
	SNeSpare_9_v    AT %MX100.3909 : BOOL;	(* Riserva e9 *)
	SNeSpare_10_v   AT %MX100.3910 : BOOL;	(* Riserva e10 *)
	SNeSpare_11_v   AT %MX100.3911 : BOOL;	(* Riserva e11 *)
	SNeSpare_12_v   AT %MX100.3912 : BOOL;	(* Riserva e12 *)
	SNeSpare_13_v   AT %MX100.3913 : BOOL;	(* Riserva e13 *)
	SNeSpare_14_v   AT %MX100.3914 : BOOL;	(* Riserva e14 *)
	SNeSpare_15_v   AT %MX100.3915 : BOOL;	(* Riserva e15 *)
	SNeSpare_16_v   AT %MX100.3916 : BOOL;	(* Riserva e16 *)
	SNeSpare_17_v   AT %MX100.3917 : BOOL;	(* Riserva e17 *)
	SNeSpare_18_v   AT %MX100.3918 : BOOL;	(* Riserva e18 *)
	SNeSpare_19_v   AT %MX100.3919 : BOOL;	(* Riserva e19 *)
	SNeSpare_20_v   AT %MX100.3920 : BOOL;	(* Riserva e20 *)
	SNeSpare_21_v   AT %MX100.3921 : BOOL;	(* Riserva e21 *)
	SNeSpare_22_v   AT %MX100.3922 : BOOL;	(* Riserva e22 *)
	SNeSpare_23_v   AT %MX100.3923 : BOOL;	(* Riserva e23 *)

	di0f AT %MX100.3924 : ARRAY[0..23] OF BOOL;	(* Forzatura valore ingressi virtuali, array bool *)
	SIeTutto_OK_f 	AT %MX100.3924 : BOOL;	(* Comandi inseriti *)
	SNePltLevOK_f 	AT %MX100.3925 : BOOL;	(* Livello pellet nel bruciatore: OK *)
	TSeOverTemp_f 	AT %MX100.3926 : BOOL;	(* Termostato caldaia: sovratemperatura *)
	SNeBurnConn_f 	AT %MX100.3927 : BOOL;	(* Bruciatore connesso *)
	FCeValvOpen_f 	AT %MX100.3928 : BOOL;	(* Valvola aperta *)
	FCeValvClos_f 	AT %MX100.3929 : BOOL;	(* Valvola chiusa *)
	SNeSpare_6_f    AT %MX100.3930 : BOOL;	(* Riserva e6 *)
	SNeSpare_7_f    AT %MX100.3931 : BOOL;	(* Riserva e7 *)
	SNeSpare_8_f    AT %MX100.3932 : BOOL;	(* Riserva e8 *)
	SNeSpare_9_f    AT %MX100.3933 : BOOL;	(* Riserva e9 *)
	SNeSpare_10_f   AT %MX100.3934 : BOOL;	(* Riserva e10 *)
	SNeSpare_11_f   AT %MX100.3935 : BOOL;	(* Riserva e11 *)
	SNeSpare_12_f   AT %MX100.3936 : BOOL;	(* Riserva e12 *)
	SNeSpare_13_f   AT %MX100.3937 : BOOL;	(* Riserva e13 *)
	SNeSpare_14_f   AT %MX100.3938 : BOOL;	(* Riserva e14 *)
	SNeSpare_15_f   AT %MX100.3939 : BOOL;	(* Riserva e15 *)
	SNeSpare_16_f   AT %MX100.3940 : BOOL;	(* Riserva e16 *)
	SNeSpare_17_f   AT %MX100.3941 : BOOL;	(* Riserva e17 *)
	SNeSpare_18_f   AT %MX100.3942 : BOOL;	(* Riserva e18 *)
	SNeSpare_19_f   AT %MX100.3943 : BOOL;	(* Riserva e19 *)
	SNeSpare_20_f   AT %MX100.3944 : BOOL;	(* Riserva e20 *)
	SNeSpare_21_f   AT %MX100.3945 : BOOL;	(* Riserva e21 *)
	SNeSpare_22_f   AT %MX100.3946 : BOOL;	(* Riserva e22 *)
	SNeSpare_23_f   AT %MX100.3947 : BOOL;	(* Riserva e23 *)

	di0m AT %MX100.3948 : ARRAY[0..23] OF BOOL;	(* Forzatura stato ingressi virtuali, array bool *)
	SIeTutto_OK_m 	AT %MX100.3948 : BOOL;	(* Comandi inseriti *)
	SNePltLevOK_m 	AT %MX100.3949 : BOOL;	(* Livello pellet nel bruciatore: OK *)
	TSeOverTemp_m 	AT %MX100.3950 : BOOL;	(* Termostato caldaia: sovratemperatura *)
	SNeBurnConn_m 	AT %MX100.3951 : BOOL;	(* Bruciatore connesso *)
	FCeValvOpen_m 	AT %MX100.3952 : BOOL;	(* Valvola aperta *)
	FCeValvClos_m 	AT %MX100.3953 : BOOL;	(* Valvola chiusa *)
	SNeSpare_6_m    AT %MX100.3954 : BOOL;	(* Riserva e6 *)
	SNeSpare_7_m    AT %MX100.3955 : BOOL;	(* Riserva e7 *)
	SNeSpare_8_m    AT %MX100.3956 : BOOL;	(* Riserva e8 *)
	SNeSpare_9_m    AT %MX100.3957 : BOOL;	(* Riserva e9 *)
	SNeSpare_10_m   AT %MX100.3958 : BOOL;	(* Riserva e10 *)
	SNeSpare_11_m   AT %MX100.3959 : BOOL;	(* Riserva e11 *)
	SNeSpare_12_m   AT %MX100.3960 : BOOL;	(* Riserva e12 *)
	SNeSpare_13_m   AT %MX100.3961 : BOOL;	(* Riserva e13 *)
	SNeSpare_14_m   AT %MX100.3962 : BOOL;	(* Riserva e14 *)
	SNeSpare_15_m   AT %MX100.3963 : BOOL;	(* Riserva e15 *)
	SNeSpare_16_m   AT %MX100.3964 : BOOL;	(* Riserva e16 *)
	SNeSpare_17_m   AT %MX100.3965 : BOOL;	(* Riserva e17 *)
	SNeSpare_18_m   AT %MX100.3966 : BOOL;	(* Riserva e18 *)
	SNeSpare_19_m   AT %MX100.3967 : BOOL;	(* Riserva e19 *)
	SNeSpare_20_m   AT %MX100.3968 : BOOL;	(* Riserva e20 *)
	SNeSpare_21_m   AT %MX100.3969 : BOOL;	(* Riserva e21 *)
	SNeSpare_22_m   AT %MX100.3970 : BOOL;	(* Riserva e22 *)
	SNeSpare_23_m   AT %MX100.3971 : BOOL;	(* Riserva e23 *)

	                          
	appWeSeq AT %MX100.3972 : UDINT;	(* Ingressi virtuali, array bool *)
	appWeh AT %MX100.3976 : UDINT;	(* appoggio intermedio dei bool in virt *)
END_VAR

]]>
					</iecDeclaration>
				</group>
				<group name="vRt2hmi">
					<iecDeclaration active="TRUE" valid="TRUE">
						<![CDATA[VAR_GLOBAL
	TmTimeStamp	AT %MW100.200	: UDINT;

	diImg	AT %MW100.204	: UDINT;	(* immagine input per hmi *)
	doImg	AT %MW100.208	: UDINT;	(* immagine output per hmi *)

	pvTCaldaia	AT	%MW100.212	: INT;	(*  *)
	pvTFumi		AT	%MW100.214	: INT;	(*  *)
	pvTMandata	AT	%MW100.216	: INT;	(*  *)
	pvTRitorno	AT	%MW100.218	: INT;	(*  *)
	pvTEsterna	AT	%MW100.220	: INT;	(*  *)
	pvTInterna	AT	%MW100.222	: INT;	(*  *)
	pvTAriaComb	AT	%MW100.224	: INT;	(*  *)
	pvTCaldaia2	AT	%MW100.226	: INT;	(*  *)
	pvPFiamma	AT	%MW100.228	: INT;	(*  *)
	phMaCy		AT	%MW100.230	: UINT;	(*  *)
	phMaCyT		AT	%MW100.232	: UINT;	(*  *)
	phFlSt		AT	%MW100.234	: UINT;	(*  *)
	phFlStT		AT	%MW100.236	: UINT;	(*  *)
	phCari		AT	%MW100.238	: UINT;	(*  *)
	phCariT		AT	%MW100.240	: UINT;	(*  *)
	phRefi		AT	%MW100.242	: UINT;	(*  *)
	phRefiT		AT	%MW100.244	: UINT;	(*  *)
	phGeMa		AT	%MW100.246	: UINT;	(*  *)
	phGeMaT		AT	%MW100.248	: UINT;	(*  *)
	ventDuty	AT	%MW100.250	: UINT;	(*  *)
	PellDuty	AT	%MW100.252	: UINT;	(*  *)
                             
	                         
                             
	alarms	AT %MW100.256	: DINT;	(* allarmi *)

	alarms0	AT %MW100.256	: INT;	(* allarmi *)
	SIaTUTTONOK	AT %MW100.256.0	: BOOL;	(* Allarme ausiliari non inseriti *)
	TTaSOC_TH1_	AT %MW100.256.1	: BOOL;	(* Allarme sonda in corto alta 1 *)

	alarms1	AT %MW100.258	: INT;	(* allarmi *)
	PTaPGASFAIL	AT %MW100.258.0	: BOOL;	(* Allarme trasd. press. gas *)
	
	mbCnNAvviamen		AT 	%MX100.260 	: 	UDINT;	(* contatore avviamenti *)
	mbCnNCariEste		AT 	%MX100.264 	: 	UDINT;	(* contatore caricamenti esterni *)
	mbCnNCariBruc		AT 	%MX100.268 	: 	UDINT;	(* contatore caricamenti bruciatore *)
	mbCnMFunz		AT 	%MX100.272 	: 	ARRAY[0..2] OF UDINT;	(* contatore funzionamento minimo *)
	mbCnMFunzMini		AT 	%MX100.272 	: 	UDINT;	(* contatore funzionamento minimo *)
	mbCnMFunzMedi		AT 	%MX100.276 	: 	UDINT;	(* contatore funzionamento medio *)
	mbCnMFunzMaxi		AT 	%MX100.280 	: 	UDINT;	(* contatore funzionamento massimo *)


	
                                                  
END_VAR

]]>
					</iecDeclaration>
				</group>
				<group name="vGlobal">
					<iecDeclaration active="FALSE"/>
				</group>
				<group name="vRt2plc">
					<iecDeclaration active="TRUE" valid="TRUE">
						<![CDATA[VAR_GLOBAL
	diImgFf AT %MW100.400 : UDINT;	(* valore forzatura input *)
	diImgFm AT %MW100.404 : UDINT;	(* stato forzatura input *)
	doImgFf AT %MW100.408 : UDINT;	(* valore forzatura output *)
	doImgFm AT %MW100.412 : UDINT;	(* stato forzatura output *)
	doImgV AT %MW100.416 : UDINT;	(* proposta output *)

//###################################################################
//
//		Tempi di funzionamento
//
//###################################################################
	
	TS2plc_sec 		AT %MW100.432 : UDINT;	(* ora UTC in secondi *)
	wDog2plc 		AT %MW100.436 : UINT;	(* watch dog dal server al PLC *)
END_VAR

VAR_GLOBAL RETAIN
	spTAlWOvert_dC AT %MX100.440 : UINT;	(* sp surrisc warning dC *)
	spTAlAOvert_dC AT %MX100.442 : UINT;	(* sp surrisc allarme dC *)
	spTmVent_s AT %MX100.444 : UINT;	(* sp ritardo spegn. ventilazione sec. *)
	xpTLock_dC AT %MX100.446 : UINT;	(* sp temp blocco scarica dC *)
	spTmWdog_mS AT %MX100.448 : UINT;	(* sp tempo insens. watchDog com mS *)
	spTBomSP_dC AT %MX100.450 : UINT;	(* sp temp. gas (bombola) dC *)
	spTBomP_d AT %MX100.452 : UINT;	(* sp P bombola dec. *)
	spTBomI_c AT %MX100.454 : UINT;	(* sp I bombola cent. *)
	spTBomD_c AT %MX100.456 : UINT;	(* sp D bombola cent. *)
	spTRisSP_dC AT %MX100.458 : UINT;	(* sp fs sovratemp riscald. dC *)
	spTRisP_d AT %MX100.460 : UINT;	(* sp P riscald. dec. *)
	spTRisI_c AT %MX100.462 : UINT;	(* sp I riscald. cent. *)
	spTRisD_c AT %MX100.464 : UINT;	(* sp D riscald. cent. *)
	spQCar_dg AT %MX100.466 : UINT;	(* sp grammi da caricare (td) dg *)
	spNUtil468 AT %MX100.468 : UINT;	(* sp durata imp. fisso erogazione mS *)
	spTSoc_dC AT %MX100.470 : UINT;	(* sp temper. variaz. minima nel tempo, dC *)
	spTmSoc_s AT %MX100.472 : UINT;	(* sp tempo analisi cambio temper., Sec *)
	spDtBt_dC AT %MX100.474 : UINT;	(* sp dT max tra sonde risc/bomb dC *)
	spDpBtBp_dB AT %MX100.476 : UINT;	(* sp Dt misurata e teorica f(P) dB *)
	spQRiserva_g	AT %MX100.478 : UINT;	(* #################################### *)
	//spTHtngPmp_dC	AT %MX100.480 : UINT;	(* #################################### *)
	//spTDhwPump_dC	AT %MX100.482 : UINT;	(* #################################### *)
	
	//geAnomRec	
	aiCfg AT %MX100.2048 : ARRAY[0..9] OF t_tara; // 200 bytes
	
//###################################################################
//
//		Impostazioni di funzionamento
//
//###################################################################

	spTCariFred_s		AT 	%MX100.2248 	: 	UINT;	(* sp tempo caric. pellet per acc. fredda *)
	spTRiVeIgni_s		AT 	%MX100.2250 	: 	UINT;	(* sp tempo ritardo ventilazione e ignitore *)
	spQVentIgni_pc		AT 	%MX100.2252 	:	UINT;	(* sp portata ventilazione in accensione *)
	spQVentInBu_pc		AT 	%MX100.2254 	:	UINT;	(* sp ventilazione iniziale propagazione fiamma *)
	spTVentIdle_s		AT 	%MX100.2256 	:	UINT;	(* sp tempo vent. prep. idle focolare *)
	spQIdleBurn_pc		AT 	%MX100.2258 	:	UINT;	(* sp ventilazione in fase di messa a riposo *)
	spTCariRipr_s		AT 	%MX100.2260 	: 	UINT;	(* sp tempo caric. pellet per ripresa focolare *)
	spTVentRipr_s		AT 	%MX100.2262 	:	UINT;	(* sp tempo ventilazione per ripresa focolare *)
	spQVentRipr_pc		AT 	%MX100.2264 	:	UINT;	(* sp portata ventilazione per ripresa focolare *)
	spTPeriCocl_ds		AT 	%MX100.2266 	: 	UINT;	(* sp tempo periodo PWM coclea *)
	spTToutFiam_s		AT 	%MX100.2268 	: 	UINT;	(* sp tempo timeout manc. fiamma *)
	spTMancAcce_s		AT 	%MX100.2270 	: 	UINT;	(* sp tempo timeout manc. accensione *)
	spTVentAcce_s		AT 	%MX100.2272 	: 	UINT;	(* sp tempo preventilazione accensione *)
	spTPropFiam_s		AT 	%MX100.2274 	: 	UINT;	(* sp tempo pausa propagazione fiamma *)
	spTFunzMinI_s		AT 	%MX100.2276 	: 	UINT;	(* sp tempo funz. al minimo prima di run pieno *)
	spTVeSpInTe_s		AT 	%MX100.2278 	: 	UINT;	(* sp tempo vent. per spegn se in temperatura *)
	spTVentPuli_s		AT 	%MX100.2280 	: 	UINT;	(* sp tempo pausa ventilazione di pulizia *)
	spQVentPuli_pc		AT 	%MX100.2282 	:	UINT;	(* sp portata ventilazione durante pulizia *)
	spTDuraPuli_s		AT 	%MX100.2284 	: 	UINT;	(* sp tempo durata ventilazione di pulizia *)
	spTDuraLava_ds		AT 	%MX100.2286 	: 	UINT;	(* sp tempo durata lavaggio per sovratemp *)
	spTCariCExt_s		AT 	%MX100.2288	: 	UINT;	(* sp tempo carico coclea esterna *)

	spKTempCald_dC		AT 	%MX100.2290	 	: 	UINT;	(* sp temperatura caldaia *)
	spKIsteCald_dK		AT 	%MX100.2292	 	: 	UINT;	(* sp isteresi ripartenza bruciatore *)
	spKLavTCald_dC		AT 	%MX100.2294	 	: 	UINT;	(* sp temperatura lavaggio caldaia (pompa riscald.) *)
	spKMaxTCald_dC		AT 	%MX100.2296	 	: 	UINT;	(* sp temperatura massima caldaia *)
	spKMaxTFumi_dC		AT 	%MX100.2298	 	: 	UINT;	(* sp temperatura max fumi *)
	spKMinTFumi_dC		AT 	%MX100.2300	 	: 	UINT;	(* sp temperatura minima fumi in funzionamento *)
	spKMxDeTCal_dK		AT 	%MX100.2302	 	: 	UINT;	(* sp delta T max tra sonde caldaia *)
	spKMinTMand_dC		AT 	%MX100.2304	 	: 	UINT;	(* sp temperatura minima mandata (climatica) *)
	spKMaxTMand_dC		AT 	%MX100.2306	 	: 	UINT;	(* sp temperatura massima mandata (climatica) *)
	spKMaxTExtr_dC		AT 	%MX100.2308	 	: 	UINT;	(* sp temperatura minima esterna (climatica) *)
	spKMinTExtr_dC		AT 	%MX100.2310	 	: 	UINT;	(* sp temperatura massima esterna (climatica) *)
	spKFsErInte_dK		AT 	%MX100.2312	 	: 	UINT;	(* sp temperatura errore reg. interna *)
	spKFsCorMan_dK		AT 	%MX100.2314	 	: 	UINT;	(* sp temperatura fondo scala correzione mandata *)

	spRPresFiam_pm		AT 	%MX100.2316 	: 	UINT;	(* sp perc. radiaz. pres. fiamma *)
	spKCampRidu_dk		AT 	%MX100.2318 	: 	UINT;	(* sp campo riduzione potenza *)

	regPars		AT	%MX100.2320	:	ARRAY[0..4, 0..1] OF	UINT;
	
	spTMandRisc_dC		AT 	%MX100.2340 	: 	UINT;	(* sp temperatura mandata riscaldamento *)
	spTVentInBu_pc		AT 	%MX100.2342 	: 	UINT;	(* sp tempo accensione ventilata iniziale *)
	spKMaxErrMa_cK		AT 	%MX100.2344 	: 	UINT;	(* sp tempo accensione ventilata iniziale *)

	spTHtngPmp_dC	AT %MX100.2346 : UINT;	(* #################################### *)
	spTDhwPump_dC	AT %MX100.2348 : UINT;	(* #################################### *)
	
//###################################################################
//
//		Contatori
//
//###################################################################

	cnNAvviamen		AT 	%MX100.2376 	: 	UDINT;	(* contatore avviamenti *)
	cnNCariEste		AT 	%MX100.2380 	: 	UDINT;	(* contatore caricamenti esterni *)
	cnNCariBruc		AT 	%MX100.2384 	: 	UDINT;	(* contatore caricamenti bruciatore *)
	cnMFunzMini		AT 	%MX100.2388 	: 	UDINT;	(* contatore funzionamento minimo *)
	cnMFunzMedi		AT 	%MX100.2392 	: 	UDINT;	(* contatore funzionamento medio *)
	cnMFunzMaxi		AT 	%MX100.2396 	: 	UDINT;	(* contatore funzionamento massimo *)


//###################################################################
//
//		Bit di comando
//
//###################################################################
	
	cmd0 AT %MW100.2402 : WORD;	(* comandi operativi *)
		cmdReset 	AT %MW100.2400.0 : BOOL;	(* comando reset *)


		cmdRstAl 	AT %MW100.2400.3 : BOOL;	(* comando reset allarmi *)

		cmdRiserva 	AT %MW100.2400.5 : BOOL;	(* era gas sel. R1234yf *)


		cmdAbort 	AT %MW100.2400.8 : BOOL;	(* cmdRiserva 8 *)


		cmd0_B 		AT %MW100.2400.11 : BOOL;	(* cmdRiserva 11 *)
		cmd0_C		AT %MW100.2400.12 : BOOL;	(* cmdRiserva 12 *)
		cmd0_D		AT %MW100.2400.13 : BOOL;	(* cmdRiserva 13 *)
		cmd0_E		AT %MW100.2400.14 : BOOL;	(* cmdRiserva 14 *)
		cmd0_F		AT %MW100.2400.15 : BOOL;	(* cmdRiserva 15 *)
	
	cmd1 AT %MW100.2402 : WORD;	(* comandi operativi *)
		cmd1_0 	AT %MW100.2402.0 : BOOL;	(* cmdRiserva 9 *)
		cmd1_1 	AT %MW100.2402.1 : BOOL;	(* cmdRiserva 9 *)
		cmd1_2 	AT %MW100.2402.2 : BOOL;	(* cmdRiserva 9 *)
		cmd1_3 	AT %MW100.2402.3 : BOOL;	(* cmdRiserva 9 *)
		cmd1_4 	AT %MW100.2402.4 : BOOL;	(* cmdRiserva 9 *)
		cmd1_5 	AT %MW100.2402.5 : BOOL;	(* cmdRiserva 9 *)
		cmd1_6 	AT %MW100.2402.6 : BOOL;	(* cmdRiserva 9 *)
		cmd1_7 	AT %MW100.2402.7 : BOOL;	(* cmdRiserva 9 *)
		cmd1_8 	AT %MW100.2402.8 : BOOL;	(* cmdRiserva 9 *)
		cmd1_9	AT %MW100.2402.9 : BOOL;	(* cmdRiserva 9 *)
		cmd1_A	AT %MW100.2402.10 : BOOL;	(* cmdRiserva 10 *)
		cmd1_B	AT %MW100.2402.11 : BOOL;	(* cmdRiserva 11 *)
		cmd1_C	AT %MW100.2402.12 : BOOL;	(* cmdRiserva 12 *)
		cmd1_D 	AT %MW100.2402.13 : BOOL;	(* cmdRiserva 13 *)
		cmd1_E 	AT %MW100.2402.14 : BOOL;	(* cmdRiserva 14 *)
		cmd1_F 	AT %MW100.2402.15 : BOOL;	(* cmdRiserva 15 *)
	

END_VAR

]]>
					</iecDeclaration>
				</group>
				<group name="_vEmulator">
					<iecDeclaration active="TRUE" valid="TRUE">
						<![CDATA[VAR_GLOBAL
	null : BOOL;

END_VAR

]]>
					</iecDeclaration>
				</group>
				<group name="kAi">
					<iecDeclaration active="TRUE" valid="TRUE">
						<![CDATA[VAR_GLOBAL CONSTANT
	tCaldaia 	: INT := 0;
	tFumi 		: INT := 1;
	tMandata 	: INT := 2;
	tRitorno 	: INT := 3;
	tEsterna	: INT := 4;
	tInterna	: INT := 5;
	tAriaComb	: INT := 6;
	tCaldaia2 	: INT := 7;
	rFiamma	 	: INT := 8;
	r9 			: INT := 9;
	lastCh		: INT := 9;
END_VAR

]]>
					</iecDeclaration>
				</group>
				<group name="kAlm">
					<iecDeclaration active="TRUE" valid="TRUE">
						<![CDATA[VAR_GLOBAL CONSTANT







	alCfg : ARRAY[0..31] OF BYTE := [
	16#09,
	16#0E,
	16#0E,
	16#0E,
	16#0E,
	16#0E,
	16#06,
	16#0E,
	16#0E,
	16#0E,
	16#00,
	16#0F,
	16#00,
	16#00,
	16#0F,
	16#0F,
	16#0E,
	16#0E,
	16#0E,
	16#0F,
	16#0F,
	16#0F,
	16#0F,
	16#00,
	16#0F,
	16#0F,
	16#0E,
	16#0F,
	16#00,
	16#00,
	16#00,
	16#00
];
	





alRit : ARRAY[0..31] OF INT := [
	10, 
	1000, 
	1000, 
	1000, 
	1000, 
	1000, 
	1000, 
	1000, 
	1000, 
	1000, 
	10000, 
	100, 
	100, 
	1000, 
	100, 
	100,
	1000,		
	1000,
	1000,
	1000,
	2000,
	2000,
	100,
	1000,
	100,
	1000,
	1000,
	100,
	0,
	0,
	0,
	0
];
END_VAR
]]>
					</iecDeclaration>
				</group>
				<group name="kPhMainCycle">
					<iecDeclaration active="TRUE" valid="TRUE">
						<![CDATA[VAR_GLOBAL CONSTANT
	mcNotRdy  		: INT := 	 0 ;   // Attesa approntamento
	mcCmdWait 		: INT := 	 5 ;   // Attesa comandi
	mcInitLoad 		: INT := 	10 ;   // Caricamento iniziale
	mcFlameWait 	: INT := 	15 ;   // Attesa segnale rilevatore fiamma
	mcInitBurn 		: INT := 	20 ;   // Combustione iniziale
	mcNoVentIgn		: INT := 	25 ;   // Propagazione fiamma s/ventilazione
	mcVentRstrt 	: INT := 	30 ;   // Ripresa ventilazione
	mcPwrSel	 	: INT := 	35 ;   // Selezione livello potenza
	mcPrsStabBurn 	: INT := 	40 ;   // Accesso diretto alla combustione stabile
	mcStableBurn 	: INT := 	45 ;   // Combustione stabile
	mcAshRemoval	: INT := 	50 ;   // Rimozione periodica cenere
	mcIdleFire	 	: INT := 	55 ;   // Mantenimento statico fiamma (in temperatura)
	mcBurnResume 	: INT := 	60 ;   // Ripresa fiamma dopo idlefire
	mcVentStart   	: INT := 	65 ;   // Avvio ventilazione per ripresa
	mcPelletFeed  	: INT := 	70 ;   // Alimentazione pellet per ripristino
	mcVentHold    	: INT := 	75 ;   // Mantenimento ventilazione
	mcIdleReturn  	: INT := 	80 ;   // Ritorno alla quiete

	mcANotRdy  		: INT := 	100 ;  // Anomalia da attesa iniziale
	mcACmdWait 		: INT := 	105 ;  // Anomalia da attesa comando
	mcAInitLoad 	: INT := 	110 ;  // Anomalia da caricamento iniziale
	mcAFlameWait 	: INT := 	115 ;  // Anomalia da attesa rilevatore fiamma
	mcAInitBurn 	: INT := 	120 ;  // Anomalia da combustione iniziale
	mcANoVentIgn	: INT := 	125 ;  // Anomalia da propagazione fiamma s/ventilazione
	mcAVentRstrt 	: INT := 	130 ;  // Anomalia da ripresa ventilazione
	mcAPwrSel	 	: INT := 	135 ;  // Anomalia da selezione livello potenza
	mcAPrsStabBurn	: INT := 	140 ;  // Anomalia da accesso diretto alla combustione stabile
	mcAStableBurn	: INT := 	145 ;  // Anomalia da combustione stabile
	mcAAshRemoval	: INT := 	150 ;  // Anomalia da rimozione periodica cenere
	mcAIdleFire	 	: INT := 	155 ;  // Anomalia da mantenimento statico fiamma
	mcABurnResume 	: INT := 	160 ;  // Anomalia da ripresa fiamma
	mcAVentStart  	: INT := 	165 ;  // Anomalia da avvio ventilazione
	mcAPelletFeed 	: INT := 	170 ;  // Anomalia da alimentazione pellet
	mcAVentHold   	: INT := 	175 ;  // Anomalia da mantenimento ventilazione
	mcAIdleReturn 	: INT := 	180 ;  // Anomalia da ritorno alla quiete

	mcAResTot 		: INT := 	185 ;  // Anomalia generale totale

	mcAnomRec 		: INT := 	200 ;  // Stato di recupero anomalie
END_VAR
]]>
					</iecDeclaration>
				</group>
				<group name="kPhFlameStatus">
					<iecDeclaration active="TRUE" valid="TRUE">
						<![CDATA[VAR_GLOBAL CONSTANT
	fsFlameOff        : INT := 	 0 ; //Fiamma spenta
	fsPreIgnition     : INT := 	 1 ; //Preparazione accensione
	fsIgniting        : INT := 	 2 ; //Accensione
	fsFlameStable     : INT := 	 3 ; //Fiamma stabile
	fsFlameLow        : INT := 	 4 ; //Fiamma debole
	fsFlameRecovery   : INT := 	 5 ; //Tentativo ripresa fiamma
	fsTempCheck       : INT := 	 6 ; //Controllo temperatura braciere
	fsPostIgnition    : INT := 	 7 ; //Post accensione
	fsFlameOutCheck   : INT := 	 8 ; //Verifica spegnimento fiamma
	fsCoolingDown     : INT := 	 9 ; //Raffreddamento braciere

	fsAFlameOff       : INT := 	100 ; //Anomalia fiamma spenta
	fsAPreIgnition    : INT := 	101 ; //Anomalia preparazione accensione
	fsAIgniting       : INT := 	102 ; //Anomalia accensione
	fsAFlameStable    : INT := 	103 ; //Anomalia fiamma stabile
	fsAFlameLow       : INT := 	104 ; //Anomalia fiamma debole
	fsAFlameRecovery  : INT := 	105 ; //Anomalia tentativo ripresa fiamma
	fsATempCheck      : INT := 	106 ; //Anomalia controllo temperatura braciere
	fsAPostIgnition   : INT := 	107 ; //Anomalia post accensione
	fsAFlameOutCheck  : INT := 	108 ; //Anomalia verifica spegnimento fiamma
	fsACoolingDown    : INT := 	109 ; //Anomalia raffreddamento braciere

	fsAResTot         : INT := 	118 ; //Anomalia generale totale

	fsAnomRec         : INT := 	200 ; //Stato di recupero anomalie
END_VAR

]]>
					</iecDeclaration>
				</group>
				<group name="kPhCaricoP">
					<iecDeclaration active="TRUE" valid="TRUE">
						<![CDATA[VAR_GLOBAL CONSTANT
	cpNotRdy  		: INT := 	 0 ;   // Attesa approntamento
	cpPause 		: INT := 	 5 ;   // Pausa carico
	cpLoad 			: INT := 	10 ;   // Caricamento attivo
	cpLoop 			: INT := 	15 ;   // Riciclo
	cpInitBurn 		: INT := 	20 ;   // 
	cpNoVentIgn		: INT := 	25 ;   // 
	cpVentRstrt 	: INT := 	30 ;   // 
	cpPwrSel	 	: INT := 	35 ;   // 
	cpStableBurn 	: INT := 	40 ;   // 
	cpAshRemoval	: INT := 	45 ;   // 
	cpIdleFire	 	: INT := 	50 ;   // 
	cpBurnResume 	: INT := 	55 ;   // 
	cpVentStart   	: INT := 	60 ;   // 
	cpPelletFeed  	: INT := 	65 ;   // 
	cpVentHold    	: INT := 	70 ;   // 
	cpIdleReturn  	: INT := 	75 ;   // 

	cpANotRdy  		: INT := 	100 ;  // Anomalia da Attesa approntamento
	cpAPause	 	: INT := 	105 ;  // Anomalia da Pausa carico
	cpALoad 		: INT := 	110 ;  // Anomalia da Caricamento attivo
	cpALoop			: INT := 	115 ;  // Anomalia da Riciclo
	cpAInitBurn 	: INT := 	120 ;  // Anomalia da 
	cpANoVentIgn	: INT := 	125 ;  // Anomalia da 
	cpAVentRstrt 	: INT := 	130 ;  // Anomalia da 
	cpAPwrSel	 	: INT := 	135 ;  // Anomalia da 
	cpAStableBurn	: INT := 	140 ;  // Anomalia da 
	cpAAshRemoval	: INT := 	145 ;  // Anomalia da 
	cpAIdleFire	 	: INT := 	150 ;  // Anomalia da 
	cpABurnResume 	: INT := 	155 ;  // Anomalia da 
	cpAVentStart  	: INT := 	160 ;  // Anomalia da 
	cpAPelletFeed 	: INT := 	165 ;  // Anomalia da 
	cpAVentHold   	: INT := 	170 ;  // Anomalia da 
	cpAIdleReturn 	: INT := 	175 ;  // Anomalia da 

	cpAResTot 		: INT := 	180 ;  // Anomalia generale totale

	cpAnomRec 		: INT := 	200 ;  // Stato di recupero anomalie
END_VAR
]]>
					</iecDeclaration>
				</group>
				<group name="kPhRefill">
					<iecDeclaration active="TRUE" valid="TRUE">
						<![CDATA[VAR_GLOBAL CONSTANT
	rfNotRdy        : INT :=      0 ;   (* Attesa approntamento*)
	rfWaitEmpt      : INT :=     10 ;   (* Attesa richiesta rifornimento*)
	rfChekEmpt      : INT :=     20 ;   (* Verifica reale mancanza pellet*)
	rfLoad          : INT :=     30 ;   (* Caricamento attivo*)
	rfCkFull        : INT :=     40 ;   (* Controllo rifornimento avvenuto*)
	rfCkNoPlt       : INT :=     50 ;   (* Controllo che davvero sia fallito il carico*)
	rfLoop          : INT :=     60 ;   (* Ricicla*)

	rfANotRdy       : INT :=    100 ;  (* Anomalia da Attesa approntamento*)
	rfAWaitEmpt     : INT :=    110 ;  (* Anomalia da Attesa richiesta rifornimento*)
	rfAChekEmpt     : INT :=    120 ;  (* Anomalia da Verifica reale mancanza pellet*)
	rfALoad         : INT :=    130 ;  (* Anomalia da Caricamento attivo*)
	rfACkFull       : INT :=    140 ;  (* Anomalia da Controllo rifornimento avvenuto*)
	rfACkNoPlt      : INT :=    150 ;  (* Anomalia da Controllo che davvero sia fallito il carico*)
	rfALoop         : INT :=    160 ;  (* Anomalia da Ricicla*)

	rfAResTot       : INT :=    200 ;  (* Anomalia generale totale*)

	rfAnomRec       : INT :=    210 ;  (* Stato di recupero anomalie*)
END_VAR
]]>
					</iecDeclaration>
				</group>
				<group name="kPhGesMand">
					<iecDeclaration active="TRUE" valid="TRUE">
						<![CDATA[VAR_GLOBAL CONSTANT
	mgNotRdy  		: INT := 	 0 ;   // Attesa approntamento
	mgCmdWait 		: INT := 	 5 ;   // Attesa comandi
	mgTempEval 		: INT := 	10 ;   // Caricamento iniziale
	mgClosProp 	: INT := 	15 ;   // Attesa segnale rilevatore fiamma
	mgOpenProp 		: INT := 	20 ;   // Combustione iniziale
	mgLoopBack		: INT := 	25 ;   // Propagazione fiamma s/ventilazione

	mgANotRdy  		: INT := 	100 ;  // Anomalia da attesa iniziale
	mgACmdWait 		: INT := 	105 ;  // Anomalia da attesa comando
	mgATempEval 	: INT := 	110 ;  // Anomalia da caricamento iniziale
	mgAClosProp 	: INT := 	115 ;  // Anomalia da attesa rilevatore fiamma
	mgAOpenProp 	: INT := 	120 ;  // Anomalia da combustione iniziale
	mgALoopBack	: INT := 	125 ;  // Anomalia da propagazione fiamma s/ventilazione

	mgAResTot 		: INT := 	180 ;  // Anomalia generale totale

	mgAnomRec 		: INT := 	200 ;  // Stato di recupero anomalie
END_VAR
]]>
					</iecDeclaration>
				</group>
			</iecVarsDeclaration>
			<functions>
				<function name="ptSet" version="1.0.0" creationDate="1685866035" lastModifiedDate="1730920007" excludeFromBuild="FALSE" excludeFromBuildIfNotDef="">
					<returnValue>BOOL</returnValue>
					<vars>
						<inputVars>
							<var name="ph" type="@t_ph"/>
							<var name="caseTo" type="INT"/>
						</inputVars>
					</vars>
					<iecDeclaration active="TRUE" valid="TRUE">
						<![CDATA[FUNCTION ptSet: BOOL

VAR_INPUT
	ph : @t_ph;
	caseTo : INT;
END_VAR

]]>
					</iecDeclaration>
					<sourceCode type="ST">
						<![CDATA[@ph.ptr := caseTo + @ph.dbg;
]]>
					</sourceCode>
				</function>
				<function name="ptTm" version="1.0.0" creationDate="1685866860" lastModifiedDate="1730920007" excludeFromBuild="FALSE" excludeFromBuildIfNotDef="">
					<returnValue>BOOL</returnValue>
					<vars>
						<inputVars>
							<var name="ph" type="@t_ph"/>
							<var name="sysTime" type="UDINT"/>
						</inputVars>
					</vars>
					<iecDeclaration active="TRUE" valid="TRUE">
						<![CDATA[FUNCTION ptTm: BOOL

VAR_INPUT
	ph : @t_ph;
	sysTime : UDINT;
END_VAR

]]>
					</iecDeclaration>
					<sourceCode type="ST">
						<![CDATA[// Gestione tempo permanenza in fase
IF @ph.ptr <> @ph.oldPtr THEN

  @ph.ptrHist := @ph.ptrHist + 1;
  @ph.ptrHist := MOD(@ph.ptrHist, 10);
  @ph.hist[@ph.ptrHist].phNo := @ph.oldPtr;
  @ph.hist[@ph.ptrHist].lasted := @ph.tmmElap;

  @ph.oldPtr := @ph.ptr;
  @ph.tmmIn := sysTime;
END_IF;

@ph.tmmElap := sysTime - @ph.tmmIn;
  
]]>
					</sourceCode>
				</function>
				<function name="ripara" version="1.0.0" creationDate="1691501128" lastModifiedDate="1729966265" excludeFromBuild="FALSE" excludeFromBuildIfNotDef="">
					<returnValue>BOOL</returnValue>
					<vars>
						<inputVars>
							<var name="anCh" type="@t_aiCh"/>
						</inputVars>
						<localVars>
							<var name="divider" type="REAL"/>
						</localVars>
					</vars>
					<iecDeclaration active="TRUE" valid="TRUE">
						<![CDATA[FUNCTION ripara: BOOL

VAR
	divider : REAL;
END_VAR

VAR_INPUT
	anCh : @t_aiCh;
END_VAR

]]>
					</iecDeclaration>
					<sourceCode type="ST">
						<![CDATA[
CASE @anCh.status OF
	1:
		@anCh.valInp := @anCh.fbRd.Value;

END_CASE;
	
// se valSym != 0, canale simulato; prende quello come valore input
IF @anCh.valSym <> 0.0 THEN 
	@anCh.valInp := @anCh.valSym;
END_IF;

//calcolo campo scala
divider := (@anCh.tmast - @anCh.tmist);

//se !=0 (evita divide by 0
IF divider <> 0.0 THEN

	//recupero NaN
	IF NOT VarVCheck(ADR(@anCh.valEng), VR_TYPE#REAL_TYPE, VAR_CHECK#VCK_NORMAL) THEN
	  @anCh.valEng := 0.0;
	END_IF;
	
	//riparametrazione
	@anCh.valEng := @anCh.itmist + (@anCh.valInp - @anCh.tmist) / divider * (@anCh.itmast - @anCh.itmist);

END_IF;


//recupero NaN
IF NOT VarVCheck(ADR(@anCh.anVal), VR_TYPE#REAL_TYPE, VAR_CHECK#VCK_NORMAL) THEN
  @anCh.anVal := 0.0;
END_IF;

//filtro media mobile
@anCh.anVal := @anCh.anVal * (1.0 - @anCh.kNuovo) + @anCh.valEng * @anCh.kNuovo;

@anCh.valEng := @anCh.anVal;

//controllo range e attivazione bit di fault
@anCh.fltOvr := @anCh.valInp > @anCh.tmaFlt;
@anCh.fltUnr := @anCh.valInp < @anCh.tmiFlt;
@anCh.fault := @anCh.fltUnr OR @anCh.fltOvr; 

]]>
					</sourceCode>
				</function>
				<function name="fPid" version="1.0.0" creationDate="1691589198" lastModifiedDate="1691681259" excludeFromBuild="FALSE" excludeFromBuildIfNotDef="">
					<returnValue>BOOL</returnValue>
					<vars>
						<inputVars>
							<var name="pid" type="@t_pidStr"/>
						</inputVars>
					</vars>
					<iecDeclaration active="FALSE"/>
					<sourceCode type="ST">
						<![CDATA[  IF @pid.Enb THEN
    (*Annullamento parametro I*)
    @pid.app_I := @pid.I;
    IF @pid.app_I = 0.0 THEN
      @pid.app_I := TO_REAL(10000000.0);
    END_IF;
    
    @pid.DT_D := @pid.D + @pid.DeT;
    
    //ERRORE: se reverse inverte output (raffredda)
    IF @pid.Reverse THEN
      @pid.ERR := (@pid.SP - @pid.PV) * -1.0;
    ELSE
      @pid.ERR := @pid.SP - @pid.PV;
    END_IF;
    
    
    IF @pid.DT_D = 0.0 THEN
      @pid.DT_D := 1.0;
    END_IF;
    
    (*Calcolo derivativo*)
    @pid.Y := @pid.Y +
    @pid.DeT *
    (@pid.PV - @pid.Y) /
    (@pid.DeT + @pid.D / @pid.KD);
    //recupero NaN su Y
    IF NOT VarVCheck(ADR(@pid.Y), VR_TYPE#REAL_TYPE, VAR_CHECK#VCK_NORMAL) THEN
      @pid.Y := 0.0;
    END_IF;
    
    
    (*calcolo proporzionale*)
    @pid.Out := @pid.BIAS +
    100.0 / @pid.P *
    (@pid.ERR - @pid.KD *
    (@pid.PV - @pid.Y));
    
    //controllo limiti uscita calcolata
    @pid.Out := LIMIT (@pid.Out, 0.0, 100.0);

    (*calcolo integrale*)
    @pid.BIAS := @pid.BIAS +
    @pid.DeT *
    (@pid.Out - @pid.BIAS) /
    (@pid.DeT + @pid.app_I);
    
    //recupero NaN su BIAS
    IF @pid.BIAS <> @pid.BIAS THEN
      @pid.BIAS := 0.0;
    END_IF;
    
    //limita bias
    //Se l'errore è oltre il valore P il bias è a 0 perchè l'uscita è a 100
    IF @pid.ERR > @pid.P THEN
      @pid.BIAS := 0.0;
    END_IF;
    
  ELSE
    @pid.Out := 0.0;
    //pid.BIAS := 0.0;
    //pid.Y := 0.0;
  END_IF;
  
]]>
					</sourceCode>
				</function>
				<function name="fPwm" version="1.0.0" creationDate="1691651758" lastModifiedDate="1695889923" excludeFromBuild="FALSE" excludeFromBuildIfNotDef="">
					<returnValue>BOOL</returnValue>
					<vars>
						<inputVars>
							<var name="a" type="@t_pwm"/>
							<var name="sysTime" type="UDINT"/>
						</inputVars>
						<localVars>
							<var name="phP" type="@t_ph"/>
						</localVars>
					</vars>
					<iecDeclaration active="FALSE"/>
					<sourceCode type="ST">
						<![CDATA[//gestione ptr fase e tempi
ptTm(ADR(@a.ph), sysTime);
//========================================================================
//inizializzazione per warning compilazione
@a.Out := FALSE;

IF NOT @a.Enable THEN
	@a.ph.ptr := 0;
END_IF;

CASE @a.ph.ptr OF
  0:
    IF @a.Enable THEN
      @a.ph.ptr := 10;
    END_IF;
    
  10:
    @a.tmcOn := TO_UINT(@a.PeriodS * @a.Percent * 10.0);
    @a.tmcOff := TO_UINT(@a.PeriodS * (100.0 - @a.Percent) * 10.0);
    @a.ph.ptr := 20;
    
  20:
    IF @a.ph.tmmElap < @a.tmcOn THEN
      @a.appOut := TRUE;
    END_IF;
    
    IF @a.ph.tmmElap >= @a.tmcOn THEN
      @a.ph.ptr := 30;
    END_IF;
    
  30:
    IF @a.ph.tmmElap < @a.tmcOff THEN
      @a.appOut := FALSE;
    END_IF;
    
    IF @a.ph.tmmElap >= @a.tmcOff THEN
      @a.ph.ptr := 0;
    END_IF;
    
END_CASE;

@a.Out := @a.appOut AND @a.Enable;
]]>
					</sourceCode>
				</function>
				<function name="boolToUdint" version="1.0.0" creationDate="1692639402" lastModifiedDate="1693131676" excludeFromBuild="FALSE" excludeFromBuildIfNotDef="">
					<returnValue>BOOL</returnValue>
					<vars>
						<inputVars>
							<var name="abp" type="PVOID"/>
							<var name="ud" type="@UDINT"/>
						</inputVars>
						<localVars>
							<var name="n" type="INT"/>
							<var name="ab" type="@BOOL" dim0="24"/>
						</localVars>
					</vars>
					<iecDeclaration active="TRUE" valid="TRUE">
						<![CDATA[FUNCTION boolToUdint: BOOL

VAR
	n : INT;
END_VAR

VAR_INPUT
	abp : PVOID;
	ud : @UDINT;
END_VAR
VAR
	ab : ARRAY[0..23] OF @BOOL;
END_VAR
]]>
					</iecDeclaration>
					<sourceCode type="ST">
						<![CDATA[@ud := 0;

FOR n := 0 TO 23 DO
	@ud := @ud + SHL(TO_UDINT(eGetBYTE(abp + TO_UDINT(n))),n);
END_FOR;

]]>
					</sourceCode>
				</function>
				<function name="getPercErog" version="1.0.0" creationDate="1693131067" lastModifiedDate="1695911714" excludeFromBuild="FALSE" excludeFromBuildIfNotDef="">
					<returnValue>REAL</returnValue>
					<vars>
						<inputVars>
							<var name="SP" type="REAL"/>
							<var name="PV" type="REAL"/>
							<var name="gain" type="REAL"/>
						</inputVars>
						<localVars>
							<var name="appLim" type="REAL"/>
							<var name="appErr" type="REAL"/>
							<var name="FSO" type="REAL"/>
						</localVars>
					</vars>
					<iecDeclaration active="TRUE" valid="TRUE">
						<![CDATA[FUNCTION getPercErog: REAL

VAR
	appLim : REAL;
	appErr : REAL;
	FSO	: REAL;
END_VAR

VAR_INPUT
	SP : REAL;
	PV : REAL;
	gain : REAL;
END_VAR

]]>
					</iecDeclaration>
					<sourceCode type="ST">
						<![CDATA[//Calcola la percentuale di attivazione valvola erogazione in funzione del fuori set
IF SP <> 0.0 THEN
	//40% della q richiesta, tra 5 e 100
	appLim := LIMIT(SP * 0.4, 5.0, 100.0);
	//quantità mancante grammi	
	appErr := SP - PV;
//	getPercErog := LIMIT((1.0 - PV / SP) * gain * 100.0, 0.25, appLim);

	//determina massima rimanenza in grammi fino a cui erogare in pieno
	FSO := 300.0;
	// se la q richiesta in grammi è più bassa, vince
	IF SP < FSO THEN
		FSO := SP;
	END_IF;
	
	getPercErog := LIMIT((appErr / FSO) * 100.0, 0.25, appLim);
END_IF;
]]>
					</sourceCode>
				</function>
				<function name="fSoc" version="1.0.0" creationDate="1693406004" lastModifiedDate="1693407568" excludeFromBuild="FALSE" excludeFromBuildIfNotDef="">
					<returnValue>BOOL</returnValue>
					<vars>
						<inputVars>
							<var name="ch" type="@t_soc"/>
							<var name="sysTime" type="UDINT"/>
						</inputVars>
					</vars>
					<iecDeclaration active="FALSE"/>
					<sourceCode type="ST">
						<![CDATA[ptTm(?@ch.ph, sysTime);


CASE @ch.ph.ptr OF
	5:
		IF @ch.pvPwr > 95.0 THEN
			@ch.oltTCurr := @ch.pvTCurr + @@ch.spTChange;
			@ch.ph.ptr := 10;
		END_IF;
	  
	10:
		//se la potenza scende sotto la soglia di controllo...
		//o se la temperatura cresce a sufficienza...
		IF @ch.pvPwr <= 95.0 OR  @ch.pvTCurr > @ch.oltTCurr THEN
			@ch.ph.ptr := 5;
		END_IF;
		
		//se trascorre il tempo di controllo senza variazione
		IF @ch.ph.tmmElap > TO_UINT(@ch.spTmChange * 100) THEN
			@ch.soc := TRUE;
			@ch.ph.ptr := 1000;
		END_IF;
	  
	1000:
	  //se viene richiesto il reset allarme (e controllo)
		IF @ch.socRst THEN
			@ch.soc := FALSE;
			@ch.ph.ptr := 5;
		END_IF;
	  
	ELSE
	  @ch.ph.ptr := 5;
    
END_CASE;

fSoc := @ch.soc;
]]>
					</sourceCode>
				</function>
				<function name="intToBoolArr" version="1.0.0" creationDate="1731275032" lastModifiedDate="1731275203" excludeFromBuild="FALSE" excludeFromBuildIfNotDef="">
					<returnValue>BOOL</returnValue>
					<vars/>
					<iecDeclaration active="TRUE" valid="FALSE">
						<![CDATA[FUNCTION intToBoolArr : BOOL
VAR_INPUT
    pUD : POINTER TO INT;		            // Puntatore al valore UDINT da convertire
    pAB : POINTER TO ARRAY[0..15] OF BOOL;	// Puntatore all'array di BOOL per il risultato
END_VAR
VAR
    n : INT;                            	// Variabile di ciclo
END_VAR
]]>
					</iecDeclaration>
					<sourceCode type="ST">
						<![CDATA[// Ciclo su ogni bit da 0 a 23
FOR n := 0 TO 23 DO
    // Verifica se il bit n-esimo è impostato e assegna il valore corrispondente nell'array puntato da pAB
    pAB^[n] := (pUD^ AND SHL(1, n)) <> 0;
END_FOR;

// Restituisce TRUE per indicare che la conversione è completa
udintToBoolArray := TRUE;
]]>
					</sourceCode>
				</function>
				<function name="boolArrToInt" version="1.0.0" creationDate="1731275390" lastModifiedDate="1731275564" excludeFromBuild="FALSE" excludeFromBuildIfNotDef="">
					<returnValue>BOOL</returnValue>
					<vars>
						<inputVars>
							<var name="abp" type="PVOID"/>
							<var name="iv" type="@INT"/>
						</inputVars>
						<localVars>
							<var name="n" type="INT"/>
							<var name="ab" type="@BOOL" dim0="16"/>
						</localVars>
					</vars>
					<iecDeclaration active="TRUE" valid="TRUE">
						<![CDATA[FUNCTION boolArrToInt: BOOL

VAR
	n : INT;
END_VAR

VAR_INPUT
	abp : PVOID;
	iv : @INT;
END_VAR
VAR
	ab : ARRAY[0..15] OF @BOOL;
END_VAR

]]>
					</iecDeclaration>
					<sourceCode type="ST">
						<![CDATA[@iv := 0;

FOR n := 0 TO 15 DO
	@iv := @iv + SHL(TO_INT(eGetBYTE(abp + TO_INT(n))),n);
END_FOR;

]]>
					</sourceCode>
				</function>
				<function name="pwrMgr" version="1.0.0" creationDate="1731357969" lastModifiedDate="1734290170" excludeFromBuild="FALSE" excludeFromBuildIfNotDef="">
					<returnValue>BOOL</returnValue>
					<vars>
						<localVars>
							<var name="ph" type="@t_ph"/>
							<var name="ptrPwrStep" type="INT"/>
						</localVars>
						<externalVars>
							<var name="b" type="t_cenTerm"/>
							<var name="spKCampRidu_dk" type="UINT">
								<descr>sp campo riduzione potenza</descr>
							</var>
							<var name="spKTempCald_dC" type="UINT">
								<descr>sp temperatura caldaia</descr>
							</var>
							<var name="spTPeriCocl_ds" type="UINT">
								<descr>sp tempo periodo PWM coclea</descr>
							</var>
							<var name="SysTime" type="UDINT"/>
							<var name="SIeTutto_OK_v" type="BOOL">
								<descr>Comandi inseriti</descr>
							</var>
							<var name="CTuBrnAuger_v" type="BOOL"/>
							<var name="mcStableBurn" type="INT">
								<descr>Combustione stabile</descr>
							</var>
							<var name="mcAshRemoval" type="INT">
								<descr>Rimozione periodica cenere</descr>
							</var>
							<var name="cpNotRdy" type="INT">
								<descr>Attesa approntamento</descr>
							</var>
							<var name="cpPause" type="INT">
								<descr>Pausa carico</descr>
							</var>
							<var name="cpLoad" type="INT">
								<descr>Caricamento attivo</descr>
							</var>
							<var name="cpLoop" type="INT">
								<descr>Riciclo</descr>
							</var>
							<var name="mbCnNCariBruc" type="UDINT">
								<descr>contatore tempo carica bruciatore</descr>
							</var>
							<var name="mbCnMFunz" type="UDINT" dim0="3">
								<descr>contatori tempi di funzionamento</descr>
							</var>
						</externalVars>
					</vars>
					<iecDeclaration active="TRUE" valid="TRUE">
						<![CDATA[FUNCTION pwrMgr: BOOL

VAR
	ph : @t_ph;
	ptrPwrStep		:	INT;
END_VAR

VAR_EXTERNAL
	b 				:	t_cenTerm;
	spKCampRidu_dk	:	UINT;	(* sp campo riduzione potenza *)
	spKTempCald_dC	:	UINT;	(* sp temperatura caldaia *)
	spTPeriCocl_ds	: 	UINT;	(* sp tempo periodo PWM coclea *)

	SysTime			:	UDINT;
	
	SIeTutto_OK_v 	:	BOOL;	(* Comandi inseriti *)
	CTuBrnAuger_v 	:	BOOL;
	
	mcStableBurn 	: 	INT;   // Combustione stabile
	mcAshRemoval	: 	INT;   // Rimozione periodica cenere

	cpNotRdy  		:	INT;   // Attesa approntamento
	cpPause 		:	INT;   // Pausa carico
	cpLoad 			:	INT;   // Caricamento attivo
	cpLoop 			:	INT;   // Riciclo
	mbCnNCariBruc	:	UDINT;	//contatore tempo carica bruciatore
	mbCnMFunz		: ARRAY[0..2] OF UDINT; //contatori tempi di funzionamento
END_VAR

]]>
					</iecDeclaration>
					<sourceCode type="ST">
						<![CDATA[
//massima potenza
IF b.pv.tCaldaia < TO_REAL(spKTempCald_dC - spKCampRidu_dk) / 10.0 THEN
	ptrPwrStep := 0;
//media potenza
ELSIF b.pv.tCaldaia < TO_REAL(spKTempCald_dC - spKCampRidu_dk / 2) / 10.0 THEN
	 ptrPwrStep := 1;
//bassa potenza
ELSE
	 ptrPwrStep := 2;
END_IF;

b.tr.regPar := b.bp.regPar[ptrPwrStep];

ph := ?b.bp.phCari;
ptTm(ph, SysTime);

CASE @ph.ptr OF
	cpNotRdy: // 0 - Attesa approntamento
		IF SIeTutto_OK_v 
			AND b.bp.phMaCy.ptr = mcStableBurn THEN

			ptSet(ph, cpPause);
		END_IF;


	cpPause:
		IF @ph.tmmElap > TO_UDINT(spTPeriCocl_ds) * 
					(100 - TO_UDINT(b.tr.regPar.pelletPerc)) THEN
					
			CTuBrnAuger_v := TRUE;
			b.bp.ventDuty := b.tr.regPar.ventPerc;
			ptSet(ph, cpLoad);
		END_IF;

	cpLoad: 	
		IF @ph.tmmElap > TO_UDINT(spTPeriCocl_ds) * 
					TO_UDINT(b.tr.regPar.pelletPerc)  THEN
			CTuBrnAuger_v := FALSE;
			mbCnNCariBruc := mbCnNCariBruc + @ph.tmmElap / 100;
			ptSet(ph, cpLoop);
		END_IF;


	cpLoop:
		mbCnMFunz[2 - ptrPwrStep] := mbCnMFunz[2 - ptrPwrStep] + TO_UDINT(spTPeriCocl_ds / 10);
		IF 	b.bp.phMaCy.ptr >= mcStableBurn OR   
			b.bp.phMaCy.ptr <= mcStableBurn THEN
				ptSet(ph, cpPause);
		ELSE
				ptSet(ph, cpNotRdy);
		END_IF;
END_CASE;	
]]>
					</sourceCode>
				</function>
			</functions>
			<functionBlocks/>
			<programs>
				<program name="aiRd" version="1.0.0" creationDate="1681392613" lastModifiedDate="1731361163" excludeFromBuild="FALSE" excludeFromBuildIfNotDef="">
					<vars>
						<localVars>
							<var name="running" type="BOOL"/>
							<var name="chPt" type="INT"/>
							<var name="done" type="BOOL"/>
						</localVars>
					</vars>
					<iecDeclaration active="TRUE" valid="TRUE">
						<![CDATA[PROGRAM aiRd

VAR
	running : BOOL;
	chPt : INT;
	done : BOOL;
END_VAR

]]>
					</iecDeclaration>
					<sourceCode type="ST">
						<![CDATA[IF NOT running THEN
	b.ai[rFiamma].fbRd(Address := 1, Channel := 0, Mode:= AD_VOLT_0_10_COMMON);
(*	b.aiCh[1].fbRd(Address := 1, Channel := 1, Mode:= AD_IDLE); 	//AD_CURR_0_20_COMMON);
	b.aiCh[2].fbRd(Address := 1, Channel := 2, Mode:= AD_IDLE); 	//AD_CURR_0_20_COMMON);
	b.aiCh[3].fbRd(Address := 1, Channel := 3, Mode:= AD_IDLE); 	//AD_THERMOCOUPLE_K);
	b.aiCh[4].fbRd(Address := 1, Channel := 4, Mode:= AD_IDLE);
	
	b.aiCh[5].fbRd(Address := 1, Channel := 5, Mode:= AD_IDLE); 	//AD_THERMOCOUPLE_K);
	b.aiCh[6].fbRd(Address := 1, Channel := 6, Mode:= AD_IDLE); 	//AD_THERMOCOUPLE_K);
	b.aiCh[7].fbRd(Address := 1, Channel := 7, Mode:= AD_IDLE); 	//AD_THERMOCOUPLE_K);
	b.aiCh[8].fbRd(Address := 1, Channel := 8, Mode:= AD_IDLE); 	//AD_THERMOCOUPLE_K);
	b.aiCh[9].fbRd(Address := 1, Channel := 9, Mode:= AD_IDLE);
*)	
	running := TRUE;
END_IF;



// -------------------------------------------------------------------------
// ANALOG INPUT ACQUISITION
// -------------------------------------------------------------------------
// Analog input multiplexing.

(*
chPt := chPt + 1; //Channel index

IF (chPt > 9) THEN 
	chPt := 0; 
END_IF;

IF chPt <> r4 AND chPt <> r9 THEN*)
chPt := rFiamma;

	b.ai[chPt].fbRd(); //Analog input acquisition
	
	IF (b.ai[chPt].fbRd.Done) THEN 
		done := ripara(ADR(b.ai[chPt]));
	END_IF;
	
	
	//.valSym <> 0 per simulare input analogico
	//ripara(ADR(b.aiCh[chPt]));

	b.pv.pFiamma := b.ai[chPt].valEng;

(*END_IF;
*)


(*
b.pv.tCaldaia 	:= b.aiCh[pTGas].anVal;
b.pv.tFumi 		:= b.aiCh[pTLiq].anVal;
b.pv.tMandata 	:= b.aiCh[THLow].anVal;
b.pv.tRitorno 	:= b.aiCh[THHigh1].anVal;
*)
]]>
					</sourceCode>
				</program>
				<program name="doWr" version="1.0.0" creationDate="1681466982" lastModifiedDate="1731277997" excludeFromBuild="FALSE" excludeFromBuildIfNotDef="">
					<vars>
						<localVars>
							<var name="tmpInt" type="INT"/>
							<var name="n" type="INT"/>
							<var name="iv" type="INT"/>
							<var name="res" type="BOOL"/>
							<var name="appB" type="PVOID"/>
							<var name="propOut" type="BOOL" dim0="16"/>
						</localVars>
					</vars>
					<iecDeclaration active="TRUE" valid="TRUE">
						<![CDATA[PROGRAM doWr

VAR
	tmpInt : INT;
	n : INT;
	iv	:	INT;
	res	:	BOOL;
	appB	: 	PVOID;
	propOut	:	ARRAY[0..15] OF BOOL;
	

END_VAR

]]>
					</iecDeclaration>
					<sourceCode type="ST">
						<![CDATA[
//LSuPRESANOMv := LSuPRESANOMv OR dbAIs.flSpiaOn OR dbAIs.flSpiaBlink;



//##################################################################
// scrittura fisica uscite 

(* trasporta bit virtuali su word*)
//appWuv := 0;

//passa array di bool a int
//FOR n := 0 TO 23 DO
//	appWuv := appWuv + SHL(TO_UDINT(do0v[n]), n);
//END_FOR;

//appWuv := appWuv OR appWuSeq OR doImgV;

(* Applica condizioni di forzatura o passaggio libero tra INT*)
//appWuh := (appWuv OR (doImgFf AND doImgFm)) AND NOT (NOT doImgFf AND doImgFm);

//doImg := appWuh;
//res	:=	boolArrToInt(b.cm, ?iv);
appB := ?b.cm.ma2nCocExt;

(* Scrive risultati sulle uscite fisiche BOOL*)
FOR n := 0 TO 7 DO
	propOut[n] := do0v[n] OR TO_BOOL(eGetBYTE(appB + TO_UDINT(n)));
	do0h[n] := (propOut[n] OR (do0f[n] AND do0m[n])) AND NOT (NOT do0f[n] AND do0m[n]);
END_FOR;

]]>
					</sourceCode>
				</program>
				<program name="init" version="1.0.0" creationDate="1681726810" lastModifiedDate="1734288098" excludeFromBuild="FALSE" excludeFromBuildIfNotDef="">
					<vars>
						<localVars>
							<var name="n" type="INT"/>
						</localVars>
					</vars>
					<iecDeclaration active="FALSE"/>
					<sourceCode type="ST">
						<![CDATA[//taratura grossolana analogiche
n := tCaldaia;
IF aiCfg[n].tmast = 0 AND aiCfg[n].itmast = 0 THEN
	aiCfg[n].tmist := 4000;
	aiCfg[n].tmast := 20000;
	aiCfg[n].tmiFlt := 4000;
	aiCfg[n].tmaFlt := 20000;
	aiCfg[n].itmist := 0;
	aiCfg[n].itmast := 3000;
	aiCfg[n].kNuovo := 1000;
	aiCfg[n].kInp := 1000;
	aiCfg[n].kEng := 100;
END_IF;	
//b.ai[n].valSym := TO_REAL(n) + 30.0;

n := tFumi;
IF aiCfg[n].tmast = 0 AND aiCfg[n].itmast = 0 THEN
	aiCfg[n].tmist := 4000;
	aiCfg[n].tmast := 20000;
	aiCfg[n].tmiFlt := 4000;
	aiCfg[n].tmaFlt := 20000;
	aiCfg[n].itmist := 0;
	aiCfg[n].itmast := 3000;
	aiCfg[n].kNuovo := 1000;
	aiCfg[n].kInp := 1000;
	aiCfg[n].kEng := 100;
END_IF;
//b.ai[n].valSym := TO_REAL(n) + 30.0;

n := tMandata;
IF aiCfg[n].tmast = 0 AND aiCfg[n].itmast = 0 THEN
	aiCfg[n].tmist := 3470;
	aiCfg[n].tmast := 20000;
	aiCfg[n].tmiFlt := 3000;
	aiCfg[n].tmaFlt := 20000;
	aiCfg[n].itmist := -100;
	aiCfg[n].itmast := 3000;
	aiCfg[n].kNuovo := 1000;
	aiCfg[n].kInp := 1000;
	aiCfg[n].kEng := 100;
END_IF;
//b.ai[n].valSym := TO_REAL(n) + 30.0;

n := tRitorno;
IF aiCfg[n].tmast = 0 AND aiCfg[n].itmast = 0 THEN
	aiCfg[n].tmist := -2000;
	aiCfg[n].tmast := 12000;
	aiCfg[n].tmiFlt := -2000;
	aiCfg[n].tmaFlt := 12000;
	aiCfg[n].itmist := -2000;
	aiCfg[n].itmast := 12000;
	aiCfg[n].kNuovo := 400;
	aiCfg[n].kInp := 100;
	aiCfg[n].kEng := 100;
END_IF;
//b.ai[n].valSym := TO_REAL(n) + 30.0;

n := tEsterna;
IF aiCfg[n].tmast = 0 AND aiCfg[n].itmast = 0 THEN
	aiCfg[n].tmist := -2000;
	aiCfg[n].tmast := 12000;
	aiCfg[n].tmiFlt := -2000;
	aiCfg[n].tmaFlt := 12000;
	aiCfg[n].itmist := -2000;
	aiCfg[n].itmast := 12000;
	aiCfg[n].kNuovo := 400;
	aiCfg[n].kInp := 100;
	aiCfg[n].kEng := 100;
END_IF;
//b.ai[n].valSym := TO_REAL(n) + 30.0;

n := tInterna;
IF aiCfg[n].tmast = 0 AND aiCfg[n].itmast = 0 THEN
	aiCfg[n].tmist := -2000;
	aiCfg[n].tmast := 12000;
	aiCfg[n].tmiFlt := -2000;
	aiCfg[n].tmaFlt := 12000;
	aiCfg[n].itmist := -2000;
	aiCfg[n].itmast := 12000;
	aiCfg[n].kNuovo := 400;
	aiCfg[n].kInp := 100;
	aiCfg[n].kEng := 100;
END_IF;
//b.ai[n].valSym := TO_REAL(n) + 30.0;

n := tAriaComb;
IF aiCfg[n].tmast = 0 AND aiCfg[n].itmast = 0 THEN
	aiCfg[n].tmist := -2000;
	aiCfg[n].tmast := 12000;
	aiCfg[n].tmiFlt := -2000;
	aiCfg[n].tmaFlt := 12000;
	aiCfg[n].itmist := -2000;
	aiCfg[n].itmast := 12000;
	aiCfg[n].kNuovo := 400;
	aiCfg[n].kInp := 100;
	aiCfg[n].kEng := 100;
END_IF;
//b.ai[n].valSym := TO_REAL(n) + 30.0;

n := tCaldaia2;
IF aiCfg[n].tmast = 0 AND aiCfg[n].itmast = 0 THEN
	aiCfg[n].tmist := -2000;
	aiCfg[n].tmast := 12000;
	aiCfg[n].tmiFlt := -2000;
	aiCfg[n].tmaFlt := 12000;
	aiCfg[n].itmist := -2000;
	aiCfg[n].itmast := 12000;
	aiCfg[n].kNuovo := 400;
	aiCfg[n].kInp := 100;
	aiCfg[n].kEng := 100;
END_IF;
//b.ai[n].valSym := TO_REAL(n) + 30.0;

n := rFiamma;
IF aiCfg[n].tmast = 0 AND aiCfg[n].itmast = 0 THEN
	aiCfg[n].tmist := 0;
	aiCfg[n].tmast := 4465;
	aiCfg[n].tmiFlt := 0;
	aiCfg[n].tmaFlt := 5000;
	aiCfg[n].itmist := 10000;
	aiCfg[n].itmast := 0;
	aiCfg[n].kNuovo := 400;
	aiCfg[n].kInp := 1000;
	aiCfg[n].kEng := 100;
END_IF;
//b.ai[n].valSym := TO_REAL(n) + 30.0;

n := r9;
IF aiCfg[n].tmast = 0 AND aiCfg[n].itmast = 0 THEN
	aiCfg[n].tmist := -2000;
	aiCfg[n].tmast := 12000;
	aiCfg[n].tmiFlt := -2000;
	aiCfg[n].tmaFlt := 12000;
	aiCfg[n].itmist := -2000;
	aiCfg[n].itmast := 12000;
	aiCfg[n].kNuovo := 400;
	aiCfg[n].kInp := 100;
	aiCfg[n].kEng := 100;
END_IF;
//b.ai[n].valSym := TO_REAL(n) + 30.0;


spTAlAOvert_dC := 650;
spTAlWOvert_dC := 600;
spTmVent_s := 30;

//parametri termoregolazione
//==========================

//init tempi sonda in corto
spTSoc_dC	:= 4;
spTmSoc_s	:= 600;

//set point par. controllo parità sonde
spDtBt_dC := 60;
spDpBtBp_dB := 60;

//b.tr.pwmRisc.PeriodS := 1.0;




spTmWdog_mS := 1500;		//15.0 s

FOR b.bk.i := 0 TO 7 DO
	do0v[b.bk.i] := FALSE;
END_FOR;

FOR n := 0 TO b.al.TSnSYSTNRDY DO
b.al.a[n].b.reqd     := TO_BOOL((alCfg[n] AND 16#01) <> 0);
b.al.a[n].b.rstMan   := TO_BOOL((alCfg[n] AND 16#02) <> 0);
b.al.a[n].b.audible  := TO_BOOL((alCfg[n] AND 16#04) <> 0);
b.al.a[n].b.active   := TO_BOOL((alCfg[n] AND 16#08) <> 0);
b.al.a[n].b.loPri    := TO_BOOL((alCfg[n] AND 16#10) <> 0);
b.al.a[n].b.blind    := TO_BOOL((alCfg[n] AND 16#20) <> 0);
b.al.a[n].insTmmSp := TO_UINT(alRit[n]);
END_FOR;

b.ai[rFiamma].status := 1;

// Ripristino contatori da tamponata
mbCnNAvviamen := cnNAvviamen;
mbCnNCariEste := cnNCariEste;
mbCnNCariBruc := cnNCariBruc;
mbCnMFunzMini := cnMFunzMini;
mbCnMFunzMedi := cnMFunzMedi;
mbCnMFunzMaxi := cnMFunzMaxi;

null:=SysSetTaskLpTime(ID_TASK_FAST, 1000); //Task Fast is executed every 500uS
null:=SysSetTaskLpTime(ID_TASK_SLOW, 5000); //Task Slow is executed every 5mS
]]>
					</sourceCode>
				</program>
				<program name="gesCom2hmi" version="1.0.0" creationDate="1681979160" lastModifiedDate="1732989059" excludeFromBuild="FALSE" excludeFromBuildIfNotDef="">
					<vars/>
					<iecDeclaration active="FALSE"/>
					<sourceCode type="ST">
						<![CDATA[TmTimeStamp := SysTime;
//diImg := appWeh;
//doImg := appWuh;

//Copia allarmi
//alarms := 0;
//FOR b.bk.i := 0 TO 27 DO
//	alarms := alarms OR SHL(TO_DINT(b.al.a[b.bk.i].b.mem),b.bk.i);
//END_FOR;
//alarms := result;



	pvTCaldaia	:=  TO_INT(b.pv.tCaldaia * 10.0);	(*  *)
	pvTFumi		:=  TO_INT(b.pv.tFumi	 * 10.0);	(*  *)
	pvTMandata	:=  TO_INT(b.pv.tMandata * 10.0);	(*  *)
	pvTRitorno	:=  TO_INT(b.pv.tRitorno * 10.0);	(*  *)
	pvTEsterna	:=  TO_INT(b.pv.tEsterna * 10.0);	(*  *)
	pvTInterna	:=  TO_INT(b.pv.tInterna * 10.0);	(*  *)
	pvTAriaComb	:=  TO_INT(b.pv.tAriaComb * 10.0);	(*  *)
	pvTCaldaia2	:=  TO_INT(b.pv.tCaldaia2 * 10.0);	(*  *)
	pvPFiamma	:= TO_INT(b.pv.pFiamma	 * 10.0);	(*  *)
	phMaCy		:= TO_UINT(b.bp.phMaCy.ptr);	(*  *)
	phMaCyT		:= TO_UINT(b.bp.phMaCy.tmmElap);	(*  *)
	phFlSt		:= TO_UINT(b.bp.phFlSt.ptr);	(*  *)
	phFlStT		:= TO_UINT(b.bp.phFlSt.tmmElap);	(*  *)
	phCari		:= TO_UINT(b.bp.phCari.ptr);	(*  *)
	phCariT		:= TO_UINT(b.bp.phCari.tmmElap);	(*  *)
	phRefi		:= TO_UINT(b.bp.phRefi.ptr);	(*  *)
	phRefiT		:= TO_UINT(b.bp.phRefi.tmmElap);	(*  *)
	phGeMa		:= TO_UINT(b.gm.ph.ptr);	(*  *)
	phGeMaT		:= TO_UINT(b.gm.ph.tmmElap);	(*  *)
	ventDuty	:= TO_UINT(b.tr.regPar.ventPerc);	(*  *)
	PellDuty	:= TO_UINT(b.tr.regPar.pelletPerc);	(*  *)

	
]]>
					</sourceCode>
				</program>
				<program name="diRd" version="1.0.0" creationDate="1681466982" lastModifiedDate="1731361502" excludeFromBuild="FALSE" excludeFromBuildIfNotDef="">
					<vars>
						<localVars>
							<var name="tmpInt" type="INT"/>
							<var name="n" type="INT"/>
						</localVars>
					</vars>
					<iecDeclaration active="FALSE"/>
					<sourceCode type="ST">
						<![CDATA[// lettura ingressi fisici, virtualizzazione

(* trasporta bit virtuali su word*)
appWeh := 0;

//passa array di bool a int
FOR n := 0 TO 23 DO
	appWeh := appWeh + SHL(TO_UDINT(di0h[n]), n);
//	di0f[n] := TO_BOOL(SHR(TO_UDINT(diImgFf), n) AND 1);
//	di0m[n] := TO_BOOL(SHR(TO_UDINT(diImgFm), n) AND 1);
END_FOR;

(* Applica condizioni di forzatura o passaggio libero tra INT*)
appWeh := (appWeh OR (diImgFf AND diImgFm)) AND NOT (NOT diImgFf AND diImgFm);

FOR n := 0 TO 23 DO
	di0v[n] := TO_BOOL(SHR(TO_UDINT(appWeh), n) AND 1);
END_FOR;

b.al.reset := (*PUeRESEALLAv OR *)cmdRstAl;


]]>
					</sourceCode>
				</program>
				<program name="_storico" version="1.0.0" creationDate="1682863309" lastModifiedDate="1729102067" excludeFromBuild="FALSE" excludeFromBuildIfNotDef="">
					<vars/>
					<iecDeclaration active="FALSE"/>
					<sourceCode type="ST">
						<![CDATA[Variabili scambio IO
.....h	hardware
.....v	virtual ("proposta" del PLC)
.....s	sequencer ("proposta" sel sequenziatore scarica)
.....f	forced (valore forzatura)
.....m	masked (stato forzatura)

per gli output, significa che 
	h = v $ (f & m) &! (!f & m)
	con h restituito come immagine

per gli input
	v = h $ (f & m) &! (!f & m)
	con v restituito come immagine

Variabili per oscilloscopio
b.gEr.percErog		10	-50
b.gEr.spQCar_g		20	-100
b.pv.wNetGErog_g	20	-100
b.gEr.ph.ptr		2	-10
mLordPesa_dg		40	-217950
b.gEr.derivaPesa_g  1	0


20241510 VRB
clonato SW
rifirmwarato la cpu
letto sonde tramite scheda 485 mbus (da tarare)
parziale pulizia


 
]]>
					</sourceCode>
				</program>
				<program name="gesCom2plc" version="1.0.0" creationDate="1681979160" lastModifiedDate="1757169959" excludeFromBuild="FALSE" excludeFromBuildIfNotDef="">
					<vars>
						<localVars>
							<var name="result" type="INT"/>
							<var name="n" type="INT"/>
						</localVars>
					</vars>
					<iecDeclaration active="TRUE" valid="TRUE">
						<![CDATA[PROGRAM gesCom2plc

VAR
	result : INT;
	n	:	INT;
END_VAR

]]>
					</iecDeclaration>
					<sourceCode type="ST">
						<![CDATA[// Sincronizzazione ora plc con quella PC
// se la differenza tra ora sistema e PC > 3 secondi,
(*
IF  ABS(SysDateGetS() - TS2plc_sec) > TO_UDINT(b.bk.DtMaxDiff) AND
	TS2plc_sec <> 0 AND
	NOT dbAIs.WDaMBPCSERV THEN
	
	b.bk.dtfRes:=SysDateSetS(TO_UDINT TO_ULINT( TS2plc_sec));
    b.bk.dtfRes:=SPLIT_DT(TO_DATE_AND_TIME(TS2plc_sec), 
				    	ADR(b.bk.LDTS.Year), 
				    	ADR(b.bk.LDTS.Month), 
				    	ADR(b.bk.LDTS.Day), 
				    	ADR(b.bk.LDTS.Hours), 
				    	ADR(b.bk.LDTS.Minutes), 
				    	ADR(b.bk.LDTS.Seconds));
END_IF;

IF wDog2plc > 32000 THEN
	wDog2plc := 32000;
END_IF;
*)
//passaggio parametri termoregolazione
(*b.tr.pidRisc.P 	:= TO_REAL(spTRisP_d	) / 10.0;
b.tr.pidRisc.I	:= TO_REAL(spTRisI_c	) / 100.0;
b.tr.pidRisc.D	:= TO_REAL(spTRisD_c	) / 100.0;*)

// warning e allarme sovratemperatura assoluta
//b.tr.spTAlWOvert_c := TO_REAL(spTAlWOvert_dC) / 10.0;
//b.tr.spTAlAOvert_c := TO_REAL(spTAlAOvert_dC) / 10.0;

//b.tr.spTSoc_C := TO_REAL(spTSoc_dC) / 10.0;
//b.tr.spTmSoc_s := TO_REAL(spTmSoc_s);

// delta massimo riscaldatore e gas
//b.tr.spDtBt_C := TO_REAL(spDtBt_dC) / 10.0;
// delta massimo temperatura mis. e t teo f(P)
//b.tr.spDpBtBp_b := TO_REAL(spDpBtBp_dB) / 10.0;
// isteresi accettabilità sovratemperatura
//OKKIO: manca in tdd
//b.tr.spTBomIst := 2.0;

FOR n := 0 TO lastCh DO
	b.ai[n].tmist := TO_REAL(aiCfg[n].tmist) / TO_REAL(aiCfg[n].kInp);
	b.ai[n].tmast := TO_REAL(aiCfg[n].tmast) / TO_REAL(aiCfg[n].kInp);
	b.ai[n].itmist := TO_REAL(aiCfg[n].itmist) / TO_REAL(aiCfg[n].kEng);
	b.ai[n].itmast := TO_REAL(aiCfg[n].itmast) / TO_REAL(aiCfg[n].kEng);
	b.ai[n].kNuovo := TO_REAL(aiCfg[n].kNuovo) / 1000.0;
	//b.ai[n].tmast := TO_REAL(aiCfg[n].tmast) / 100.0;
END_FOR;

FOR n := 0 TO 3 DO
	b.bp.regPar[n].ventPerc := TO_INT(regPars[n, 0]);
	b.bp.regPar[n].pelletPerc := TO_INT(regPars[n, 1]);
END_FOR;

b.gm.tMandReq := TO_REAL(spTMandRisc_dC) / 10.0;
b.gm.spTHtngPmp := TO_REAL(spTHtngPmp_dC) / 10.0;
b.gm.spTDhwPump := TO_REAL(spTDhwPump_dC) / 10.0;

]]>
					</sourceCode>
				</program>
				<program name="gesVent" version="1.0.0" creationDate="1682871930" lastModifiedDate="1731340388" excludeFromBuild="FALSE" excludeFromBuildIfNotDef="">
					<vars>
						<localVars>
							<var name="DOut0" type="SysSetPhrDO">
								<descr>Manage peripheral outputs</descr>
							</var>
							<var name="PWM0" type="PWMOut_v1">
								<descr>PWM management</descr>
							</var>
						</localVars>
					</vars>
					<iecDeclaration active="TRUE" valid="TRUE">
						<![CDATA[PROGRAM gesVent

VAR
	//Out 	: BOOL;	(* Out signal *)
	DOut0 	: SysSetPhrDO;	(* Manage peripheral outputs *)
	PWM0 	: PWMOut_v1;	(* PWM management *)
	
END_VAR

]]>
					</iecDeclaration>
					<sourceCode type="ST">
						<![CDATA[// *****************************************************************************
// PROGRAM "ST_PWMOut_v1"
// *****************************************************************************
// Is managed a PWM out, the program is executed on the Fast task, so it's
// executed at every 1 mS. This allows to have a maximum frequency of 10 Hz with
// possibility to set the duty with a resolution of 1 %.
// -----------------------------------------------------------------------------

    // -------------------------------------------------------------------------
    // INITIALIZATION
    // -------------------------------------------------------------------------
    // Initialize variables.

    IF (SysFirstLoop) THEN

        // Peripheral outputs settings.

        DOut0.Address:=255; //CPU module address
        DOut0.Mode:=DO_8_LL; //Management mode
        DOut0.Mask:=16#00000001; //Mask output 0

        // PWM out settings.

        PWM0.Enable:=TRUE; //Enable
        PWM0.Frequency:=10.0; //Frequency (Hz)
        PWM0.TMin:=0.001; //Minimum output time

    END_IF;

    // -------------------------------------------------------------------------
    // PWM OUT MANAGEMENT
    // -------------------------------------------------------------------------
    // Manage the PWM out.

    PWM0(Duty := TO_REAL(b.bp.ventDuty)); //PWM management
    //Out:=PWM0.Out; //Out signal

    IF NOT(PWM0.Out) THEN
        DOut0.Value:=DOut0.Value AND 16#FFFFFFFE; //Reset output
    ELSE
        DOut0.Value:=DOut0.Value OR 16#00000001; //Set output
    END_IF;

    DOut0(); //Manage peripheral outputs
]]>
					</sourceCode>
				</program>
				<program name="gesAll" version="1.0.0" creationDate="1682930061" lastModifiedDate="1731361711" excludeFromBuild="FALSE" excludeFromBuildIfNotDef="">
					<vars>
						<localVars>
							<var name="n" type="UINT"/>
						</localVars>
					</vars>
					<iecDeclaration active="FALSE"/>
					<sourceCode type="ST">
						<![CDATA[//1 Azzeramento uscite condivise prima di aggiornamento
b.al.flSpiaOn := FALSE;
b.al.flSpiaBlink := FALSE;
b.al.flSonoro := FALSE;

FOR n := 0 TO TO_UINT(b.al.TSnSYSTNRDY) DO
  IF b.al.a[n].b.active THEN
    //gestore tempo permanenza in fase
	ptTm(?b.al.a[n].ph, SysTime);
    
    //  0 - allarme inattivo
    //4 se arriva allarme...
    b.al.a[n].b.live := b.al.a[n].b.input XOR b.al.a[n].b.reqd;
    
    //5
    IF b.al.a[n].ph.ptr = 0 OR b.al.a[n].ph.ptr = 5 THEN
      b.al.a[n].b.mem := FALSE;
    END_IF;
    
    CASE b.al.a[n].ph.ptr OF
      0:// 00 - Spento
        //==================================
        
        //9  00.05 -  Vai ad attesa attivazione
        IF b.al.a[n].b.live THEN
          b.al.a[n].ph.ptr := b.al.ph05RitAttivaz;
        END_IF;
        
      5:// 05 - Attesa insensibilità
        //==================================
        
        //05.00 - Vai a spento per rientro allarme
        IF NOT b.al.a[n].b.live THEN
          b.al.a[n].ph.ptr := b.al.phRiposo;
        END_IF;
        
        //05.10 e 20 - Vai ad allarme silenzioso (o sonoro) attivo perchè tempo trascorso
        IF b.al.a[n].ph.tmmElap > b.al.a[n].insTmmSp
          AND b.al.a[n].b.live THEN
          b.al.a[n].b.mem := TRUE;
          b.al.a[n].count := b.al.a[n].count + 1;
          b.al.flSpiaOn := NOT b.al.a[n].b.blind;
          IF b.al.a[n].b.audible THEN
            b.al.a[n].ph.ptr := b.al.ph10AlSonLamp;
          ELSE
            b.al.flSonoro := TRUE;
            b.al.a[n].ph.ptr := b.al.ph20AlLamp;
          END_IF;
        END_IF;
        
      10:// 10 - Allarme sonoro attivo
        //==================================
        
        b.al.flSonoro := TRUE;
        b.al.flSpiaOn := NOT b.al.a[n].b.blind;
        
        //10.00 - Vai a spento per rientro allarme
        IF NOT b.al.a[n].b.live AND NOT b.al.a[n].b.rstMan THEN
          b.al.a[n].ph.ptr := b.al.phRiposo;
        END_IF;
        
        //10.20 e 40
        IF b.al.ack THEN
          IF b.al.a[n].b.loPri THEN //10.40 - Vai a solo luminoso lampeggio raro per tacitazione
            b.al.a[n].ph.ptr := b.al.ph40AlLampLowP;
          ELSE //10.20 - Vai a attiva flag luce on e sonoro
            b.al.a[n].ph.ptr := b.al.ph20AlLamp;
          END_IF;
        END_IF;
        
        //10.30 -  Vai a attesa reset per rientro allarme
        IF NOT b.al.a[n].b.live THEN
          b.al.a[n].ph.ptr := b.al.ph30Lamp;
        END_IF;
        
        
      20:// 20 - Allarme NON sonoro attivo
        //==================================
        
        b.al.flSpiaOn := NOT b.al.a[n].b.blind;
        
        //a 30 e 0 
        IF NOT b.al.a[n].b.live THEN
          //20.30 - Vai a lampada accesa, attesa reset per rientro allarme NON mrst
          IF b.al.a[n].b.rstMan THEN
            b.al.a[n].ph.ptr := b.al.ph30Lamp;
          ELSE //20.00 - Vai a spento per rientro all, non è mrst
            b.al.a[n].ph.ptr := b.al.phRiposo;
          END_IF;
        END_IF;
        
      30:// 30 - Lampada accesa, attesa reset
        //==================================
        
        b.al.flSpiaOn := NOT b.al.a[n].b.blind;
        
        //30.00 - Vai a spento, per reset manuale
        IF b.al.reset THEN
          b.al.a[n].ph.ptr := b.al.phRiposo;
        END_IF;
        
        //30.35 - Vai ad allarme in riattivazione. lampada accesa
        IF b.al.a[n].b.live THEN
          b.al.a[n].ph.ptr := b.al.ph35RitRiattivaz;
        END_IF;
        
      35:// 35 - Allarme in riattivazione, Lampada accesa 
        
        b.al.flSpiaOn := NOT b.al.a[n].b.blind;
        
        //35.30 - Torna a lampada accesa, attesa reset per rientro allarme
        IF NOT b.al.a[n].b.live THEN
          b.al.a[n].ph.ptr := b.al.ph30Lamp;
        END_IF;
        
        //35.10 - Vai ad allarme sonoro attivo per tempo trascorso
        IF b.al.a[n].b.live AND b.al.a[n].ph.tmmElap > b.al.a[n].insTmmSp THEN
          //35.10 - Vai ad allarme sonoro attivo per tempo trascorso
          IF b.al.a[n].b.audible THEN
            b.al.a[n].ph.ptr := b.al.ph10AlSonLamp;
          ELSE//35.20 - Vai ad allarme NON sonoro attivo per tempo trascorso
            b.al.a[n].ph.ptr := b.al.ph20AlLamp;
          END_IF;
        END_IF;
        
      40:// 40 - Allarme attivo bassa priorità (lampeggio)
        //40.00 - Vai a spento per rientro allarme
        IF NOT b.al.a[b.al.ptrAl].b.live THEN
          b.al.a[n].ph.ptr := b.al.ph20AlLamp;
        END_IF;
        
        
        ;
      ELSE  // Statement section ELSE
        ;
    END_CASE;
    
  ELSE
    b.al.a[n].b.input := FALSE;
    b.al.a[n].b.live := FALSE;
    b.al.a[n].b.mem := FALSE;
    b.al.a[n].b.piuPiu := FALSE;
    
  END_IF;
  
END_FOR;

]]>
					</sourceCode>
				</program>
				<program name="tarana" version="1.0.0" creationDate="1682954577" lastModifiedDate="1731361221" excludeFromBuild="FALSE" excludeFromBuildIfNotDef="">
					<vars>
						<localVars>
							<var name="trig" type="R_TRIG"/>
							<var name="n" type="INT"/>
						</localVars>
					</vars>
					<iecDeclaration active="FALSE"/>
					<sourceCode type="ST">
						<![CDATA[trig(CLK := SysClock100);

//eseguito ogni 200 mS
IF trig.Q THEN
	b.au.ptrChCfg := b.au.ptrChCfg + 1;
	IF b.au.ptrChCfg > 9 THEN
			b.au.ptrChCfg := 0;
	END_IF;
		// prevenzione div0 prima di aggiornare tarature canale
	n := b.au.ptrChCfg;
	IF 	aiCfg[n].kInp > 0 AND aiCfg[n].kEng > 0 THEN
		//limiti punti lettura (campo scheda: 0..10, 4..20, -170..480...)
		b.ai[n].tmist := TO_REAL(aiCfg[n].tmist) / TO_REAL(aiCfg[n].kInp);
		b.ai[n].tmast := TO_REAL(aiCfg[n].tmast) / TO_REAL(aiCfg[n].kInp);
		//limiti campo input "sano"
		b.ai[n].tmiFlt := TO_REAL(aiCfg[n].tmiFlt) / TO_REAL(aiCfg[n].kInp);
		b.ai[n].tmaFlt := TO_REAL(aiCfg[n].tmaFlt) / TO_REAL(aiCfg[n].kInp);
		//limiti campo scala (ingegneristico)
		b.ai[n].itmist := TO_REAL(aiCfg[n].itmist) / TO_REAL(aiCfg[n].kEng);
		b.ai[n].itmast := TO_REAL(aiCfg[n].itmast) / TO_REAL(aiCfg[n].kEng);

		//Calcolo e controllo range 0..1 del filtro	
		b.ai[n].kNuovo := LIMIT(TO_REAL(aiCfg[n].kNuovo) / 10000.0, 
								0.001, 
								0.999999);
	END_IF;

END_IF;
]]>
					</sourceCode>
				</program>
				<program name="gesAllIst" version="1.0.0" creationDate="1682956916" lastModifiedDate="1731361396" excludeFromBuild="FALSE" excludeFromBuildIfNotDef="">
					<vars>
						<localVars>
							<var name="n" type="INT"/>
						</localVars>
					</vars>
					<iecDeclaration active="FALSE"/>
					<sourceCode type="ST">
						<![CDATA[//gestione wDog comunicazione in centesimi di secondo
wDog2plc := wDog2plc + 1 - b.au.disWd;



(* 0 Allarme ausiliari non inseriti *)
b.al.SIaTUTTONOK := b.al.a[b.al.SInTUTTONOK].b.mem;  
b.al.a[b.al.SInTUTTONOK].b.input := SIeTutto_OK_v;


IF NOT b.al.SIaTUTTONOK THEN
  
	(* 1 Allarme sonda in corto alta 1 *)
	b.al.TOaACCEFALL := b.al.a[b.al.TOnACCEFALL].b.mem;  
//	b.al.a[b.al.TTnSOC_TH1_].b.input := b.tr.tcTH1.soc;
	
	

ELSE

	FOR n := 1 TO b.al.TSnSYSTNRDY DO
		b.al.a[n].b.input := b.al.a[n].b.reqd;
	END_FOR;

	b.al.reset:= TRUE;

END_IF;
  
]]>
					</sourceCode>
				</program>
				<program name="logiGen" version="1.0.0" creationDate="1683565104" lastModifiedDate="1757169959" excludeFromBuild="FALSE" excludeFromBuildIfNotDef="">
					<vars>
						<localVars>
							<var name="phPw" type="t_ph"/>
						</localVars>
					</vars>
					<iecDeclaration active="FALSE"/>
					<sourceCode type="ST">
						<![CDATA[//Comando spie segnalazione
//LSuPRESANOMv := cmdHlAnomBlink AND SysClock1000 OR cmdHlAnomOnFix;
//LSuCICLATTIv := cmdHlStrtBlink AND SysClock1000 OR cmdHlStrtOnFix;
//LSuSISTPRONv := cmdHlStopBlink AND SysClock1000 OR cmdHlStopOnFix;
//LSuCARICOMPv := cmdHlDoneBlink AND SysClock1000 OR cmdHlDoneOnFix;


//CTuVAUXSUPPv := cmdAuxSupplyOn;

// Gestione tempo permanenza in fase
ptTm(?phPw, SysTime);

CTuHtngPump_v := b.pv.tCaldaia > b.gm.spTHtngPmp AND b.cm.ru0nRisc;
CTuDhwPump_v := b.pv.tCaldaia >  b.gm.spTDhwPump AND b.cm.ru1nAcs;


(*
CASE phPw.ptr OF

	0:
		IF wDog2plc > 1000 THEN
			ptSet(?phPw, 10);
		END_IF;
	
	10:
		IF PUeSTARCICLv AND PUeSTOPCICLv THEN
			//SNuPWRCYCPCv := TRUE;
			ptSet(?phPw, 20);
		END_IF;

		IF wDog2plc < 1000 THEN
			ptSet(?phPw, 0);
		END_IF;
	
	20:
		IF phPw.tmmElap > 1000 THEN
			//SNuPWRCYCPCv := FALSE;
			ptSet(?phPw, 30);
		END_IF;
	
	30:
		IF phPw.tmmElap > 120000 OR wDog2plc < 1000 THEN
			ptSet(?phPw, 0);
		END_IF;
	
END_CASE;

*)
// Gestione start/stop/pausa ciclo




]]>
					</sourceCode>
				</program>
				<program name="bkCalc" version="1.0.0" creationDate="1691316530" lastModifiedDate="1734289426" excludeFromBuild="FALSE" excludeFromBuildIfNotDef="">
					<vars>
						<localVars>
							<var name="ph" type="@t_ph"/>
						</localVars>
					</vars>
					<iecDeclaration active="TRUE" valid="TRUE">
						<![CDATA[PROGRAM bkCalc

VAR
	ph : @t_ph;
END_VAR
]]>
					</iecDeclaration>
					<sourceCode type="ST">
						<![CDATA[//se lavoro con 134:
ph := ?b.au.phSD;
ptTm(ph, SysTime);

CASE @ph.ptr OF
	0: // 0 - pausa
		IF @ph.tmmElap >= 60000 THEN
			ptSet(ph, 10);
		END_IF;
	10: // 10 - salva dati in tamponata
		cnNAvviamen := mbCnNAvviamen;
		cnNCariEste := mbCnNCariEste;
		cnNCariBruc := mbCnNCariBruc;
		cnMFunzMini := mbCnMFunzMini;
		cnMFunzMedi := mbCnMFunzMedi;
		cnMFunzMaxi := mbCnMFunzMaxi;
		ptSet(ph, 0);
END_CASE;
]]>
					</sourceCode>
				</program>
				<program name="ManInit" version="1.0.0" creationDate="1681726810" lastModifiedDate="1731361249" excludeFromBuild="FALSE" excludeFromBuildIfNotDef="">
					<vars>
						<localVars>
							<var name="n" type="INT"/>
						</localVars>
					</vars>
					<iecDeclaration active="FALSE"/>
					<sourceCode type="ST">
						<![CDATA[IF b.au.flAbilSpInit THEN
	//taratura grossolana analogiche
	n := tCaldaia;
	aiCfg[n].tmiFlt := 200;
	aiCfg[n].tmaFlt := 10000;
	b.ai[n].status := 2;
	
	n := tFumi;
	aiCfg[n].tmiFlt := 200;
	aiCfg[n].tmaFlt := 10000;
	b.ai[n].status := 2;
	//b.ai[n].valSym := 9.0;
	
	n := tMandata;
	aiCfg[n].tmiFlt := 200;
	aiCfg[n].tmaFlt := 10000;
	b.ai[n].status := 2;
	//b.ai[n].valSym := 7.3;
	
	n := tRitorno;
	aiCfg[n].tmiFlt := -12000;
	aiCfg[n].tmaFlt := 17000;
	b.ai[n].status := 2;
	//b.ai[n].valSym := 25.0;
	
	n := tEsterna;
	aiCfg[n].tmiFlt := -12000;
	aiCfg[n].tmaFlt := 17000;
	b.ai[n].status := 2;
	//b.ai[n].valSym := 25.0;
	
	n := tInterna;
	aiCfg[n].tmiFlt := -12000;
	aiCfg[n].tmaFlt := 17000;
	b.ai[n].status := 2;
	//b.ai[n].valSym := TO_REAL(n) + 30.0;
	
	n := tAriaComb;
	aiCfg[n].tmiFlt := -12000;
	aiCfg[n].tmaFlt := 17000;
	b.ai[n].status := 2;
	//b.ai[n].valSym := TO_REAL(n) + 30.0;
	
	n := tCaldaia2;
	aiCfg[n].tmiFlt := -12000;
	aiCfg[n].tmaFlt := 17000;
	b.ai[n].status := 2;
	//b.ai[n].valSym := TO_REAL(n) + 30.0;
	
	spTAlAOvert_dC := 650;
	spTAlWOvert_dC := 600;
	spTmVent_s := 30;
	spDtBt_dC := 50;
	(*
	FOR n := 0 TO 15 DO
	dbAIs.a[n].b.reqd     := TO_BOOL((dbAIsCfg[n] AND 16#01) <> 0);
	dbAIs.a[n].b.rstMan   := TO_BOOL((dbAIsCfg[n] AND 16#02) <> 0);
	dbAIs.a[n].b.audible  := TO_BOOL((dbAIsCfg[n] AND 16#04) <> 0);
	dbAIs.a[n].b.active   := TO_BOOL((dbAIsCfg[n] AND 16#08) <> 0);
	dbAIs.a[n].b.loPri    := TO_BOOL((dbAIsCfg[n] AND 16#10) <> 0);
	dbAIs.a[n].b.blind    := TO_BOOL((dbAIsCfg[n] AND 16#20) <> 0);
	dbAIs.a[n].insTmmSp := TO_UINT(dbAIsRit[n]);
	END_FOR;
	*)
	b.au.flAbilSpInit := FALSE;
END_IF;
]]>
					</sourceCode>
				</program>
				<program name="gesLamp" version="1.0.0" creationDate="1725015406" lastModifiedDate="1731099764" excludeFromBuild="FALSE" excludeFromBuildIfNotDef="">
					<vars>
						<localVars>
							<var name="modStart" type="INT"/>
							<var name="modStop" type="INT"/>
						</localVars>
					</vars>
					<iecDeclaration active="TRUE" valid="TRUE">
						<![CDATA[PROGRAM gesLamp

VAR
	modStart : INT;
	modStop : INT;
END_VAR

]]>
					</iecDeclaration>
					<sourceCode type="ST">
						<![CDATA[(*

Funzionamento spie:
 
                                                    | p. start 	| p. stop   |
 ---------------------------------------------------|-----------|-----------|
 0 Attesa approntamento								|	0		|	0		|
 1 Attesa comandi									|	0		|	0		|
 2 Attesa pulsante fisico							|	2		|	0		|
 3 acquisizione tara								|	1		|	2		|
 4 verifica stabilità tara							|	1		|	2		|
 5 attesa (sospensione) carica						|	2		|	1		|
 6 avvio erogazione con PWM grossolano				|	1		|	2		|
 7 erogazione grossolana							|	1		|	2		|
 8 erogazione fine									|	1		|	2		|
 9 attesa stabilizzazione							|	1		|	0		|
10 verifica completamento							|	0		|	0		|
11 verifica completamento							|	0		|	0		|
12 completamento sequenza							|	0		|	0		|
13 completamento sequenza							|	0		|	0		|
													|			|			|
200 Recovery anom., wait azz. tutti comandi			|	0		|	4		|

modi:
0 off
1 on
2 blink 1000
4 blink 100
8 blink 1000|100
10 on 900 off 100
*)


	 

//gestore fasi erogazione
(*
CASE b.gEr.ph.ptr OF

	geNotRdy: // 0 Attesa approntamento
		modStart := 0;
		modStop := 0;

	geCmdWait: // 1 Attesa comandi
		modStart := 0;
		modStop := 0;
	
	geBtnWait: // 2 Attesa pulsante fisico
		modStart := 2;
		modStop := 0;

//============================================		
// Ciclo erogazione freon
		
	geGetTare: // 3 acquisizione tara		
		modStart := 1;
		modStop := 2;
		LSuCARICOMPv := FALSE;

	geStabTare: // 4 verifica stabilità tara
		modStart := 1;
		modStop := 2;
		
	geErgPause:	// 5 attesa (sospensione) carica
		modStart := 2;
		modStop := 1;
	
	geErgStrt: // 6 avvio erogazione con PWM grossolano
		modStart := 1;
		modStop := 2;

	geErgCoarse: // 7 erogazione grossolana
		modStart := 1;
		modStop := 2;
	
	geErgFine: // 8 erogazione fine
		modStart := 1;
		modStop := 2;

	geErgStbWait: // 9 attesa stabilizzazione
		modStart := 1;
		modStop := 2;

	geErgStbChk: // 10 verifica completamento
		modStart := 0;
		modStop := 0;

	geErgFixPls: // 11 verifica completamento
		modStart := 0;
		modStop := 0;

	geErgStabEnd: // 12 completamento sequenza
		modStart := 0;
		modStop := 0;
	
	geErgEnd: // 13 completamento sequenza
		modStart := 4;
		modStop := 4;
		LSuCARICOMPv := TRUE;
	
	geAnomRec: // 200 Recovery anomalie, attende azzeramento tutti i comandi
		modStart := 0;
		modStop := 4;
	
END_CASE;
*)
	 
				
				
]]>
					</sourceCode>
				</program>
				<program name="mbMasterRtu" version="1.0.0" creationDate="1728845703" lastModifiedDate="1731364317" excludeFromBuild="FALSE" excludeFromBuildIfNotDef="">
					<vars>
						<localVars>
							<var name="i" type="UDINT">
								<descr>Aux counter</descr>
							</var>
							<var name="n" type="INT">
								<descr>Aux pointer</descr>
							</var>
							<var name="ptrMod" type="INT">
								<descr>Puntatore modulo Pt100</descr>
								<initValue>2</initValue>
							</var>
							<var name="done" type="BOOL">
								<descr>esito d'appoggio</descr>
							</var>
							<var name="SerialOrTCP" type="BOOL">
								<descr>FALSE:Serial, TRUE:TCP communication</descr>
								<initValue>FALSE</initValue>
							</var>
							<var name="CaseNr" type="USINT">
								<descr>Program case</descr>
							</var>
							<var name="Sp" type="SysSerialPort">
								<descr>Serial port</descr>
							</var>
							<var name="TCPClient" type="SysTCPClient">
								<descr>TCP client management</descr>
							</var>
							<var name="RCoils" type="BOOL" dim0="16">
								<descr>Coil status (Read)</descr>
							</var>
							<var name="WCoils" type="BOOL" dim0="16">
								<descr>Coil status (Write)</descr>
							</var>
							<var name="MMdb" type="ModbusMaster_v3">
								<descr>Modbus master FB</descr>
							</var>
						</localVars>
					</vars>
					<iecDeclaration active="TRUE" valid="TRUE">
						<![CDATA[PROGRAM mbMasterRtu

VAR
	i 			: UDINT;				(* Aux counter *)
	n			: INT;					(* Aux pointer *)
	ptrMod		: INT := 2;					(* Puntatore modulo Pt100 *)
	done		: BOOL;					(* esito d'appoggio *)
	SerialOrTCP : BOOL := FALSE;		(* FALSE:Serial, TRUE:TCP communication *)
	CaseNr 		: USINT;				(* Program case *)
	Sp 			: SysSerialPort;		(* Serial port *)
	TCPClient 	: SysTCPClient;			(* TCP client management *)
	RCoils 		: ARRAY[0..15] OF BOOL;	(* Coil status (Read) *)
	WCoils 		: ARRAY[0..15] OF BOOL;	(* Coil status (Write) *)
    MMdb 		: ModbusMaster_v3; 		(* Modbus master FB *)
END_VAR

]]>
					</iecDeclaration>
					<sourceCode type="ST">
						<![CDATA[// *****************************************************************************
// PROGRAM "ST_ModbusMaster"
// *****************************************************************************
// Are executed all possible Modbus commands with a connection over another
// SlimLine. It's possible to test all the three possible Modbus types (Serial
// RTU, serial ascii, TCP).
// -----------------------------------------------------------------------------

    // -------------------------------------------------------------------------
    // INITIALIZATION
    // -------------------------------------------------------------------------
    // Program initializations.

    IF (SysFirstLoop) THEN

        // Serial port settings.

        Sp.COM:=ADR('COM2'); //COM port definition
        Sp.Baudrate:=9600; //Baudrate
        Sp.Parity:='N'; //Parity
        Sp.DataBits:=8; //Data bits
        Sp.StopBits:=1; //Stop bits
        Sp.DTRManagement:=DTR_AUTO_WO_TIMES; //DTR management
        Sp.DTRComplement:=FALSE; //DTR complement
        Sp.EchoFlush:=FALSE; //Received echo flush
        Sp.DTROnTime:=0; //DTR On time delay (mS)
        Sp.DTROffTime:=0; //DTR Off time delay (mS)
        Sp.FlushTm:=0; //Flush time (mS)
        Sp.RxSize:=0; //Rx buffer size
        Sp.TxSize:=0; //Tx buffer size

        // Modbus master settings.

        MMdb.Absolute:=FALSE; //Absolute addressing
        MMdb.Node:=1; //Node number
        MMdb.Timeout:=T#1s; //Timeout time
        MMdb.Delay:=T#100ms; //Delay time
	    MMdb.Address:=1; //Modbus register address
	    MMdb.Points:=SIZEOF(RHRegs)/2; //Modbus register points
    END_IF;

    // -------------------------------------------------------------------------
    // MODBUS MANAGEMENT
    // -------------------------------------------------------------------------
    // Eseguo selezione canale comunicazione.

        Sp(Open:=TRUE); //Serial port management
        MMdb.File:=Sp.File; //File pointer
        MMdb.Type:=MODBUS_PROTOCOL#MDB_RTU; //Modbus protocol type

    // Manage the modbus master communication.

    MMdb(); //Modbus master
    IF NOT(SysFIsOpen(MMdb.File)) THEN MMdb.Enable:=FALSE; CaseNr:=0; RETURN; END_IF;

	IF ptrMod > 3 THEN
		ptrMod := 2;	
	END_IF;
	
    // ---------------------------------------------------------------------
    // Execute a Read holding registers.
		
	MMdb.Enable		:= TRUE; 	//Modbus enable
    MMdb.FCode		:= 16#03; 	//Modbus function code
    MMdb.Address	:= 1; 		//Modbus register address
    MMdb.Node		:= TO_USINT(ptrMod); 	//Node number
    MMdb.Points		:= 4; 		//Modbus register points
	MMdb.Buffer		:= ADR(RHRegs[ptrMod - 2, 0]); //Memory buffer address
	
    IF NOT(MMdb.Done) THEN RETURN; END_IF;
    

	ptrMod := ptrMod + 1;

    
    MMdb.Enable		:=FALSE; //Modbus enable
    
	b.ai[tCaldaia].valInp 	:= TO_REAL(TO_INT(RHRegsInt[0])) / 10.0;
    b.ai[tFumi].valInp 	 	:= TO_REAL(TO_INT(RHRegsInt[1])) / 10.0;
    b.ai[tMandata].valInp 	:= TO_REAL(TO_INT(RHRegsInt[2])) / 10.0;
    b.ai[tRitorno].valInp 	:= TO_REAL(TO_INT(RHRegsInt[3])) / 10.0;
    b.ai[tEsterna].valInp 	:= TO_REAL(TO_INT(RHRegsInt[4])) / 10.0;
    b.ai[tInterna].valInp 	:= TO_REAL(TO_INT(RHRegsInt[5])) / 10.0;
    b.ai[tAriaComb].valInp 	:= TO_REAL(TO_INT(RHRegsInt[6])) / 10.0;
    b.ai[tCaldaia2].valInp 	:= TO_REAL(TO_INT(RHRegsInt[7])) / 10.0;
	
	FOR n := 0 TO lastCh DO
		done := ripara(ADR(b.ai[n]));
	END_FOR;
	
	b.pv.tCaldaia 	:= b.ai[tCaldaia].valEng;
	b.pv.tFumi 		:= b.ai[tFumi].valEng;
	b.pv.tMandata 	:= b.ai[tMandata].valEng;
	b.pv.tRitorno 	:= b.ai[tRitorno].valEng;
	b.pv.tEsterna 	:= b.ai[tEsterna].valEng;
	b.pv.tInterna 	:= b.ai[tInterna].valEng;
	b.pv.tAriaComb	:= b.ai[tAriaComb].valEng;
	b.pv.tCaldaia2 	:= b.ai[tCaldaia2].valEng;
	
]]>
					</sourceCode>
				</program>
				<program name="mainCycle" version="1.0.0" creationDate="1730720729" lastModifiedDate="1734288450" excludeFromBuild="FALSE" excludeFromBuildIfNotDef="">
					<vars>
						<localVars>
							<var name="ph" type="@t_ph"/>
						</localVars>
					</vars>
					<iecDeclaration active="TRUE" valid="TRUE">
						<![CDATA[PROGRAM mainCycle

VAR
	ph : @t_ph;
END_VAR

]]>
					</iecDeclaration>
					<sourceCode type="ST">
						<![CDATA[(*
	mcNotRdy  		: INT := 	 0 ; //Attesa approntamento
	mcCmdWait 		: INT := 	 1 ; //Attesa comandi
	mcInitLoad 		: INT := 	 2 ; //Caricamento iniziale
	mcFlameWait 	: INT := 	 3 ; //Attesa segnale rilevatore fiamma
	mcNoVentIgn		: INT := 	 4 ; //Propagazione fiamma s/ventilazione
	mcVentRstrt 	: INT := 	 5 ; //Ripresa ventilazione
	mcPwrSel	 	: INT := 	 6 ; //Selezione livello potenza
	mcStableBurn 	: INT := 	 7 ; //Combustione stabile
	mcAshRemoval	: INT := 	 8 ; //Rimozione periodica cenere
	mcIdleFire	 	: INT := 	 9 ; //Mantenimento statico fiamma (in temperatura)
	mcBurnResume 	: INT := 	10 ; //Ripresa fiamma dopo idlefire
	mcVentStart   	: INT := 	11 ; //Avvio ventilazione per ripresa
	mcPelletFeed  	: INT := 	12 ; //Alimentazione pellet per ripristino
	mcVentHold    	: INT := 	13 ; //Mantenimento ventilazione
	mcIdleReturn  	: INT := 	14 ; //Ritorno alla quiete
*)

// Gestione tempo permanenza in fase
ph := ?b.bp.phMaCy;
ptTm(ph, SysTime);

IF 	((NOT b.cm.ru0nRisc 
	AND NOT b.cm.ru1nAcs)
	OR b.al.SIaTUTTONOK) 
	AND @ph.ptr > mcCmdWait THEN
		ptSet(ph, mcNotRdy);
END_IF;

// Salto a combustione normale (usato durante sviluppo/trasmissione SW)
IF b.cm.mcStblBurn THEN
	ptSet(ph, mcPrsStabBurn);
	b.cm.mcStblBurn := FALSE;
END_IF;

CASE @ph.ptr OF
	mcNotRdy: // 0 - Attesa approntamento
		CTuBrnAuger_v := FALSE;
		CTuIgnHeatr_v := FALSE;
		CTuVentCmd_v := FALSE;
		b.bp.ventDuty := 100;
		IF SIeTutto_OK_v 
			AND @ph.tmmElap > 100 THEN
				ptSet(ph, mcCmdWait);
		END_IF;

	mcCmdWait: // 5 - Attesa comandi
		IF b.cm.ru0nRisc 
		OR b.cm.ru1nAcs 
		AND NOT b.al.TSaHIGHTEMP THEN
			CTuBrnAuger_v := TRUE;
			ptSet(ph, mcInitLoad);
		END_IF;

	mcInitLoad: // 10 - Caricamento iniziale
		//Attesa ritardo avvio ventilazione
		IF @ph.tmmElap > TO_UDINT(spTRiVeIgni_s) * 1000 THEN
			CTuIgnHeatr_v := TRUE;
			CTuVentCmd_v := TRUE;
			b.bp.ventDuty := TO_INT(spQVentIgni_pc);
		END_IF;
		//Scaduto tempo carico acc. a freddo
		IF @ph.tmmElap > TO_UDINT(spTCariFred_s) * 1000
				OR b.cm.mcFNextStp THEN
			b.cm.mcFNextStp := FALSE;			
			CTuBrnAuger_v := FALSE;
			CTuIgnHeatr_v := TRUE;
			CTuVentCmd_v := TRUE;
			b.bp.ventDuty := TO_INT(spQVentIgni_pc);
			ptSet(ph, mcFlameWait);
		END_IF;

	mcFlameWait: // 15 - Attesa segnale rilevatore fiamma
		IF b.pv.pFiamma > TO_REAL(spRPresFiam_pm) / 100.0 THEN
			CTuIgnHeatr_v := FALSE;
			b.bp.ventDuty := TO_INT(spQVentInBu_pc);
			mbCnNAvviamen := mbCnNAvviamen + 1;
			ptSet(ph, mcInitBurn);
		END_IF;

	mcInitBurn:	//	20 - Accensione braciere ventilata
		IF @ph.tmmElap > TO_UDINT(spTVentInBu_pc) * 1000 THEN
			CTuIgnHeatr_v := FALSE;
			CTuVentCmd_v := FALSE;			
			ptSet(ph, mcNoVentIgn);
		END_IF;


	mcNoVentIgn: // 25 - Propagazione fiamma s/ventilazione
		IF @ph.tmmElap > TO_UDINT(spTPropFiam_s) * 1000 THEN
			CTuIgnHeatr_v := FALSE;
			CTuVentCmd_v := TRUE;
			b.bp.ventDuty := TO_INT(b.bp.phLowPwr.ventPerc);
			ptSet(ph, mcVentRstrt);
		END_IF;

	mcVentRstrt: // 30 - Ripresa ventilazione
		IF @ph.tmmElap > TO_UDINT(spTFunzMinI_s) * 1000 THEN
			ptSet(ph, mcPwrSel);
		END_IF;

	mcPwrSel: // 35 - Selezione livello potenza
		IF @ph.tmmElap > 100 THEN
			ptSet(ph, mcStableBurn);
		END_IF;

	mcPrsStabBurn: // 40 - accesso diretto alla combustione stabile
		CTuIgnHeatr_v := FALSE;
		CTuBrnAuger_v := FALSE;
		CTuVentCmd_v := TRUE;
		ptSet(ph, mcStableBurn);

	mcStableBurn: // 45 - Combustione stabile
		
		pwrMgr();
		//set point raggiunto
		IF b.pv.tCaldaia > TO_REAL(spKTempCald_dC) / 10.0 THEN
			b.bp.ventDuty := TO_INT(spQIdleBurn_pc);
			CTuBrnAuger_v := FALSE;
			ptSet(ph, mcIdleFire);
		END_IF;
		
		//Ciclo pulizia da fare
		IF @ph.tmmElap > TO_UDINT(spTVentPuli_s) * 1000 THEN
			b.bp.ventDuty := TO_INT(spQVentPuli_pc);
			CTuBrnAuger_v := FALSE;
			ptSet(ph, mcAshRemoval);
		END_IF;

	mcAshRemoval: // 50 - Rimozione periodica cenere
		IF @ph.tmmElap > TO_UDINT(spTDuraPuli_s) * 1000 THEN
			b.bp.ventDuty := TO_INT(b.tr.regPar.ventPerc);	//Okkio
			ptSet(ph, mcStableBurn);
		END_IF;

	mcIdleFire: // 55 - Mantenimento statico fiamma (in temperatura)
		IF @ph.tmmElap > TO_UDINT(spTVentIdle_s) * 1000 THEN
			CTuVentCmd_v := FALSE;
			b.bp.ventDuty := 100;
		END_IF;
		IF b.pv.tCaldaia < TO_REAL(spKTempCald_dC - spKIsteCald_dK) / 10.0 THEN
			CTuBrnAuger_v := TRUE;
			ptSet(ph, mcBurnResume);
		END_IF;

	mcBurnResume: // 60 - Ripresa fiamma dopo idlefire
		IF @ph.tmmElap > TO_UDINT(spQVentInBu_pc) * 1000 THEN
			CTuVentCmd_v := TRUE;
			b.bp.ventDuty := TO_INT(spQVentInBu_pc);
		END_IF;
		IF @ph.tmmElap > TO_UDINT(spTCariRipr_s) * 1000 THEN
			CTuBrnAuger_v := FALSE;
			CTuVentCmd_v := TRUE;
			b.bp.ventDuty := TO_INT(spQVentRipr_pc);
			ptSet(ph, mcVentStart);
		END_IF;

	mcVentStart: // 65 - Avvio ventilazione per ripresa
		IF @ph.tmmElap > 100 THEN
			ptSet(ph, mcPelletFeed);
		END_IF;

	mcPelletFeed: // 70 - Alimentazione pellet per ripristino
		IF @ph.tmmElap > 100 THEN
			ptSet(ph, mcVentHold);
		END_IF;

	mcVentHold: // 75 - Mantenimento ventilazione
		IF @ph.tmmElap > TO_UDINT(spTFunzMinI_s) * 1000 THEN
			ptSet(ph, mcIdleReturn);
		END_IF;

	mcIdleReturn: // 80 - Ritorno alla quiete
		IF @ph.tmmElap > 1000 THEN
			ptSet(ph, mcPwrSel);
		END_IF;
END_CASE;
]]>
					</sourceCode>
				</program>
				<program name="flameStatus" version="1.0.0" creationDate="1730840616" lastModifiedDate="1731449098" excludeFromBuild="FALSE" excludeFromBuildIfNotDef="">
					<vars>
						<localVars>
							<var name="ph" type="@t_ph"/>
						</localVars>
					</vars>
					<iecDeclaration active="FALSE"/>
					<sourceCode type="ST">
						<![CDATA[// Gestione tempo permanenza in fase
ph := ?b.bp.phFlSt;
ptTm(ph, SysTime);

CASE @ph.ptr OF
	fsFlameOff:
		IF b.bp.phMaCy.ptr > mcFlameWait THEN
			ptSet(ph, fsPreIgnition); // Fiamma spenta, passa a preparazione accensione
		END_IF;

	fsPreIgnition:
		IF b.bp.phMaCy.ptr > mcInitBurn THEN
			ptSet(ph, fsIgniting); // Preparazione accensione, passa a fase accensione
		END_IF;

	fsIgniting:
		IF b.bp.phMaCy.ptr > mcPwrSel THEN
			ptSet(ph, fsFlameStable); // Accensione, passa a fiamma stabile
		END_IF;

	fsFlameStable:
		IF @ph.tmmElap > 500 THEN
			ptSet(ph, fsFlameLow); // Fiamma stabile, verifica stato fiamma debole
		END_IF;

	fsFlameLow:
		IF @ph.tmmElap > 500 THEN
			ptSet(ph, fsFlameRecovery); // Fiamma debole, tenta ripresa fiamma
		END_IF;

	fsFlameRecovery:
		IF @ph.tmmElap > 500 THEN
			ptSet(ph, fsTempCheck); // Tentativo ripresa fiamma, passa a controllo temperatura
		END_IF;

	fsTempCheck:
		IF @ph.tmmElap > 500 THEN
			ptSet(ph, fsPostIgnition); // Controllo temperatura braciere, passa a fase post accensione
		END_IF;

	fsPostIgnition:
		IF @ph.tmmElap > 500 THEN
			ptSet(ph, fsFlameOutCheck); // Post accensione, verifica spegnimento fiamma
		END_IF;

	fsFlameOutCheck:
		IF @ph.tmmElap > 500 THEN
			ptSet(ph, fsCoolingDown); // Verifica spegnimento fiamma, passa a raffreddamento
		END_IF;

	fsCoolingDown:
		IF @ph.tmmElap > 500 THEN
			ptSet(ph, fsFlameOff); // Raffreddamento braciere, torna a fiamma spenta
		END_IF;

END_CASE;
]]>
					</sourceCode>
				</program>
				<program name="refill" version="1.0.0" creationDate="1731400532" lastModifiedDate="1734288450" excludeFromBuild="FALSE" excludeFromBuildIfNotDef="">
					<vars>
						<localVars>
							<var name="ph" type="@t_ph"/>
							<var name="retry" type="BOOL"/>
						</localVars>
					</vars>
					<iecDeclaration active="TRUE" valid="TRUE">
						<![CDATA[PROGRAM refill


VAR
	ph : @t_ph;
	retry	:	BOOL;
END_VAR

]]>
					</iecDeclaration>
					<sourceCode type="ST">
						<![CDATA[ph := ?b.bp.phRefi;
ptTm(ph, SysTime);


CASE @ph.ptr OF
	
	rfNotRdy: // 0 - Attesa approntamento
		IF SIeTutto_OK_v 
			AND (b.cm.ru0nRisc OR b.cm.ru1nAcs) THEN
				ptSet(ph, rfWaitEmpt);
		END_IF;

	rfWaitEmpt: // 10 - Attesa segnale vuoto
		IF NOT SNePltLevOK_v THEN
			ptSet(ph, rfChekEmpt);
		END_IF;

	rfChekEmpt: // 20 - Controllo che resti a 0 10"
		IF @ph.tmmElap > 10000 THEN
			CTuExtAuger_v := TRUE;
			ptSet(ph, rfLoad);
		END_IF;

		//se era una falsa lettura, torno ad attendere
		IF SNePltLevOK_v THEN
			ptSet(ph, rfWaitEmpt);
		END_IF;


	rfLoad: // 30 - Carica a tempo
		IF @ph.tmmElap > TO_UDINT(spTCariCExt_s) * 1000 THEN
			CTuExtAuger_v := FALSE;
			mbCnNCariEste := mbCnNCariEste  + 1;
			ptSet(ph, rfCkFull);
		END_IF;

	rfCkFull: // 40 - Controllo riempimento riuscito
		IF SNePltLevOK_v THEN
			retry := FALSE;
			ptSet(ph, rfWaitEmpt);
		END_IF;

		IF @ph.tmmElap > 10000 THEN
			IF NOT retry THEN
				retry := TRUE;
				ptSet(ph, rfWaitEmpt);
			ELSE
				ptSet(ph, rfACkFull);
			END_IF;
				
		END_IF;

//	rfCkNoPlt: // 50 - Controllo riempimento riuscito

//	rfLoop: // 60 - Controllo riempimento riuscito

END_CASE;
]]>
					</sourceCode>
				</program>
				<program name="gesMand" version="1.0.0" creationDate="1731428838" lastModifiedDate="1731536734" excludeFromBuild="FALSE" excludeFromBuildIfNotDef="">
					<vars>
						<localVars>
							<var name="ph" type="@t_ph"/>
						</localVars>
					</vars>
					<iecDeclaration active="TRUE" valid="TRUE">
						<![CDATA[PROGRAM gesMand

VAR
	ph : @t_ph;
END_VAR

]]>
					</iecDeclaration>
					<sourceCode type="ST">
						<![CDATA[ph := ?b.gm.ph;
ptTm(ph, SysTime);

//Errore: positivo se la mandata è più alta della richiesta
b.gm.errTMand := b.pv.tMandata - b.gm.tMandReq;

CASE @ph.ptr OF
	mgNotRdy: // 0 - Attesa
		IF NOT b.al.SIaTUTTONOK THEN
			FCuMixVOpen_v := FALSE;			
			FCuMixVClse_v := FALSE;			
			ptSet(ph, mgCmdWait);
		END_IF;
	mgCmdWait:
		IF b.cm.ru0nRisc 
				AND b.pv.tCaldaia > 55.0 
				AND @ph.tmmElap > 15000 THEN
			ptSet(ph, mgTempEval);
		END_IF;
			
	mgTempEval:
		//se la mandata è bassa di oltre x °C		
		IF b.gm.errTMand < -b.gm.spMaxErr THEN
			FCuMixVOpen_v := TRUE;			
			ptSet(ph, mgOpenProp);
		END_IF;
		
		//se la mandata è alta di oltre x °C		
		IF b.gm.errTMand > b.gm.spMaxErr THEN
			FCuMixVClse_v := TRUE;			
			ptSet(ph, mgClosProp);
		END_IF;
	
	mgOpenProp:
		IF @ph.tmmElap > TO_UDINT(5000.0 * ABS(b.gm.errTMand) / 10.0)  THEN
			FCuMixVOpen_v := FALSE;			
			ptSet(ph, mgLoopBack);
		END_IF;
	
	mgClosProp:			
		IF @ph.tmmElap > TO_UDINT(5000.0 * b.gm.errTMand / 10.0) THEN
			FCuMixVOpen_v := FALSE;			
			ptSet(ph, mgLoopBack);
		END_IF;
	
	mgLoopBack:
		FCuMixVOpen_v := FALSE;			
		FCuMixVClse_v := FALSE;			
		ptSet(ph, mgCmdWait);

END_CASE;
]]>
					</sourceCode>
				</program>
				<program name="gesMqtt" version="1.0.0" creationDate="1732986854" lastModifiedDate="1732989308" excludeFromBuild="FALSE" excludeFromBuildIfNotDef="">
					<vars>
						<localVars>
							<var name="Publish" type="BOOL">
								<descr>Publish command</descr>
							</var>
							<var name="TCPClient" type="SysTCPClient">
								<descr>TCP client management</descr>
							</var>
							<var name="FIFO" type="FIFOFile_v1">
								<descr>FIFO on file</descr>
							</var>
							<var name="MQTT" type="MQTTClient_v3">
								<descr>MQTT client FB</descr>
							</var>
							<var name="retVal" type="BOOL"/>
							<var name="trig1" type="BOOL"/>
							<var name="Encode" type="BOOL">
								<descr>Encode command</descr>
							</var>
							<var name="JSONObject" type="STRING" length="128">
								<descr>JSON object</descr>
							</var>
							<var name="ENr" type="USINT" dim0="3">
								<descr>Error number</descr>
							</var>
						</localVars>
					</vars>
					<iecDeclaration active="TRUE" valid="TRUE">
						<![CDATA[PROGRAM gesMQTT
VAR
    Publish : BOOL; (* Publish command *)
//    BOOLValue : ARRAY[0..1] OF BOOL := [true, false]; (* BOOL value [Tx][Rx] *)
//    REALValue : ARRAY[0..1] OF REAL := [10.0, 0.0]; (* REAL value [Tx][Rx] *)
//    STRINGValue : ARRAY[0..1] OF STRING[ 16 ]; (* STRING value [Rx] *)
//    SPData : ARRAY[0..2] OF MQTT_TS_DATA; (* MQTT topic subscribe data *)
    TCPClient : SysTCPClient; (* TCP client management *)
    FIFO : FIFOFile_v1; (* FIFO on file *)
    MQTT : MQTTClient_v3; (* MQTT client FB *)
    retVal	: BOOL;
    trig1	: BOOL;
    
    
    
    Encode 		: BOOL; 					(* Encode command *)
    JSONObject 	: STRING[ 128 ]; 			(* JSON object *)
    ENr : ARRAY[0..2] OF USINT; 			(* Error number *)
END_VAR
]]>
					</iecDeclaration>
					<sourceCode type="ST">
						<![CDATA[// *****************************************************************************
// PROGRAM "ST_MQTTClient"
// *****************************************************************************
// This program connects to a free broker, it shows how to subscribe and
// publish topics on it.
// -----------------------------------------------------------------------------

    // -------------------------------------------------------------------------
    // INITIALIZATION
    // -------------------------------------------------------------------------
    // Initialize the FBs parameters.

    IF (SysFirstLoop) THEN

        // Set FIFO parameters.

        FIFO.FIFOFilename:=eNULL; //Path and name of FIFO file
        FIFO.FIFOSize:=2048; //FIFO file size
        FIFO.FIFOIDx:=eNULL; //FIFO indexes

        // Set TCPClient parameters.

        TCPClient.PeerAdd:=ADR('10.0.0.107'); //Peer address
        TCPClient.PeerPort:=1883; //Peer port
        TCPClient.LocalAdd:=ADR('0.0.0.0'); //Local address
        TCPClient.LocalPort:=0; //Local port
        TCPClient.FlushTm:=0; //Flush time (mS)
        TCPClient.LifeTm:=90; //Life time (S)
        TCPClient.RxSize:=512; //Rx buffer size
        TCPClient.TxSize:=512; //Tx buffer size

        // Set MQTTClient parameters.

        MQTT.SpyOn:=TRUE; //Spy active
        MQTT.FIFOFile:=ADR(FIFO); //FIFO on file
        MQTT.CFlags:=16#02; //Clean session
        MQTT.Username:=eNULL; //Broker username
        MQTT.Password:=eNULL; //Broker password
        MQTT.ClientID:=eNULL; //Client identifier
        MQTT.KeepAlive:=T#90s; //Keep alive time
        MQTT.Delay:=T#50ms; //Send delay time
        MQTT.Timeout:=T#2s; //Execution timeout

        // Topic subscribe definitions.

        //MQTT.TSData:=ADR(SPData); //Topic subscribe data
        //MQTT.TSNumber:=SIZEOF(SPData)/SIZEOF(SPData[0]); //Topic subscribe number

        //retVal := MQTT.Subscribe(0, ADR('plc/dati'), ADR(BOOLValue[1]), SIZEOF(BOOLValue[1]), 0);
    END_IF;


	IF b.cm.flCdataLog AND trig1 <> SysClock100 THEN
		trig1 := SysClock100;
		Publish := TRUE;
	END_IF;
	
    // -------------------------------------------------------------------------
    // MQTT MANAGEMENT
    // -------------------------------------------------------------------------
    // FBs management.

    TCPClient(Connect:=MQTT.Connect); //TCPClient management
    MQTT(Enable:=TRUE, File:=TCPClient.File); //MQTTClient management

    // To publish topics set by debug the "Publish" variable.

    IF NOT(Publish) THEN RETURN; END_IF;
    Publish:=FALSE; //Publish command
//    retVal := TO_BOOL(MQTT.Publish(ADR('ElsistTest/BOOLValue'), ADR(BOOLValue[0]), SIZEOF(BOOLValue[0]), FALSE, 1));
//    retVal := MQTT.Publish(ADR('ElsistTest/REALValue'), ADR(REALValue[0]), SIZEOF(REALValue[0]), FALSE, 1);

    // ------------------------------------------------------------------------
    // CREATE JSON OBJECT
    // ------------------------------------------------------------------------
    // Create a JSON object.


    retVal := TO_BOOL(Sysmemset(ADR(JSONObject), 0, SIZEOF(JSONObject))); //Initialize the JSON object

    ENr[0]:=JSONEncoder(ADR(JSONObject), SIZEOF(JSONObject), ADR('tCaldaia'), REAL_TYPE, ADR(b.pv.tCaldaia), 1);
    ENr[1]:=JSONEncoder(ADR(JSONObject), SIZEOF(JSONObject), ADR('tFumi'), REAL_TYPE, ADR(b.pv.tFumi), 1);
    ENr[2]:=JSONEncoder(ADR(JSONObject), SIZEOF(JSONObject), ADR('tMandata'), REAL_TYPE, ADR(b.pv.tMandata), 1);
(*    ENr[3]:=JSONEncoder(ADR(JSONObject), SIZEOF(JSONObject), ADR('tRitorno'), REAL_TYPE, ADR(b.pv.tRitorno), 1);
    ENr[4]:=JSONEncoder(ADR(JSONObject), SIZEOF(JSONObject), ADR('tEsterna'), REAL_TYPE, ADR(b.pv.tEsterna), 1);
    ENr[5]:=JSONEncoder(ADR(JSONObject), SIZEOF(JSONObject), ADR('tInterna'), REAL_TYPE, ADR(b.pv.tInterna), 1);
    ENr[6]:=JSONEncoder(ADR(JSONObject), SIZEOF(JSONObject), ADR('tCaldaia2'), REAL_TYPE, ADR(b.pv.tCaldaia2), 1);
    ENr[7]:=JSONEncoder(ADR(JSONObject), SIZEOF(JSONObject), ADR('pFiamma'), REAL_TYPE, ADR(b.pv.pFiamma), 1);
*)
    retVal := TO_BOOL(SysWrSpyData(SPY_ASCII, 0, 16#00000001, ADR('ST_JSONEncode'), ADR(JSONObject)));
    
    
    
    
    
    //Di nuovo MQTT
    //retVal := TO_BOOL(SysVsnprintf(ADR(STRINGValue[0]), 16, ADR('%.3f'), REAL_TYPE, ADR(REALValue[0])));
    retVal := MQTT.Publish(ADR('plc/dati'), ADR(JSONObject), LEN(JSONObject), FALSE, 1);
]]>
					</sourceCode>
				</program>
			</programs>
			<macros/>
			<structs>
				<struct name="t_ph" version="1.0.0" excludeFromBuild="FALSE" excludeFromBuildIfNotDef="">
					<title>Dati gestione fase switch</title>
					<vars>
						<var name="ptr" type="INT">
							<descr>Puntatore fase corrente</descr>
						</var>
						<var name="oldPtr" type="INT">
							<descr>Puntatore fase di provenienza</descr>
						</var>
						<var name="dbg" type="INT">
							<descr>Usato in debug, sfasa i salti</descr>
						</var>
						<var name="tmmIn" type="UDINT">
							<descr>Istante assoluto entrata in fase</descr>
						</var>
						<var name="tmmElap" type="UDINT">
							<descr>Tempo trascorso dall'entrata in fase</descr>
						</var>
						<var name="hist" type="t_phHiStep" dim0="11">
							<descr>Ultimi passaggi</descr>
						</var>
						<var name="ptrHist" type="INT">
							<descr>Puntatore passaggi</descr>
						</var>
					</vars>
					<iecDeclaration active="TRUE" valid="TRUE">
						<![CDATA[t_ph: STRUCT
	ptr : INT;	(* Puntatore fase corrente *)
	oldPtr : INT;	(* Puntatore fase di provenienza *)
	dbg : INT;	(* Usato in debug, sfasa i salti *)
	tmmIn : UDINT;	(* Istante assoluto entrata in fase *)
	tmmElap : UDINT;	(* Tempo trascorso dall'entrata in fase *)
	hist : ARRAY[0..10] OF t_phHiStep;	(* Ultimi passaggi *)
	ptrHist : INT;	(* Puntatore passaggi *)
END_STRUCT;

]]>
					</iecDeclaration>
				</struct>
				<struct name="t_aiCh" version="1.0.0" excludeFromBuild="FALSE" excludeFromBuildIfNotDef="">
					<title>Canale analogico</title>
					<vars>
						<var name="valInp" type="REAL">
							<descr>Lettura in punti (da scheda anal.)</descr>
						</var>
						<var name="valEng" type="REAL">
							<descr>Lettura riparametrata ingegneristica</descr>
						</var>
						<var name="anVal" type="REAL">
							<descr>Lettura filtrata</descr>
						</var>
						<var name="tmist" type="REAL">
							<descr>Minimo punti (inizio scala)</descr>
						</var>
						<var name="tmiFlt" type="REAL">
							<descr>Minimo salvo fault</descr>
						</var>
						<var name="tmast" type="REAL">
							<descr>Massimo punti (fondo scala)</descr>
						</var>
						<var name="tmaFlt" type="REAL">
							<descr>Massimo salvo fault</descr>
						</var>
						<var name="itmist" type="REAL">
							<descr>Minimo ingegneristico (inizio scala)</descr>
						</var>
						<var name="itmast" type="REAL">
							<descr>Massimo ingegneristico (fondo scala)</descr>
						</var>
						<var name="kNuovo" type="REAL">
							<descr>0&lt;k&lt;=1 frazione di nuovo valore. K piccolo, molto filtrato</descr>
						</var>
						<var name="valSym" type="REAL">
							<descr>se != 0, sostituisce il valore letto. Per simulazione</descr>
						</var>
						<var name="status" type="INT">
							<descr>abilitazione, futuri significati</descr>
						</var>
						<var name="done" type="BOOL"/>
						<var name="fault" type="BOOL"/>
						<var name="fltOvr" type="BOOL">
							<descr>fault overrange</descr>
						</var>
						<var name="fltUnr" type="BOOL">
							<descr>fault underrange</descr>
						</var>
						<var name="fbRd" type="SysGetAnInp"/>
					</vars>
					<iecDeclaration active="TRUE" valid="TRUE">
						<![CDATA[t_aiCh: STRUCT
	valInp 	: REAL;	(* Lettura in punti (da scheda anal.) *)
	valEng 	: REAL;	(* Lettura riparametrata ingegneristica *)
	anVal 	: REAL;	(* Lettura filtrata *)
	tmist 	: REAL;	(* Minimo punti (inizio scala) *)
	tmiFlt 	: REAL;	(* Minimo salvo fault *)
	tmast 	: REAL;	(* Massimo punti (fondo scala) *)
	tmaFlt 	: REAL;	(* Massimo salvo fault *)
	itmist 	: REAL;	(* Minimo ingegneristico (inizio scala) *)
	itmast 	: REAL;	(* Massimo ingegneristico (fondo scala) *)
	kNuovo 	: REAL;	(* 0<k<=1 frazione di nuovo valore. K piccolo, molto filtrato *)
	valSym 	: REAL;	(* se != 0, sostituisce il valore letto. Per simulazione *)
	status	: INT;	(* abilitazione, futuri significati *)
	done 	: BOOL;
	fault 	: BOOL;
	fltOvr	: BOOL;	(* fault overrange *)
	fltUnr	: BOOL;	(* fault underrange *)
	fbRd : SysGetAnInp;
END_STRUCT;

]]>
					</iecDeclaration>
				</struct>
				<struct name="t_dev" version="1.0.0" excludeFromBuild="FALSE" excludeFromBuildIfNotDef="">
					<vars>
						<var name="i" type="BOOL">
							<descr>Input comando uscita</descr>
						</var>
						<var name="inh" type="BOOL">
							<descr>Input disattivazione uscita (alto-&gt; out=0)</descr>
						</var>
						<var name="iFs" type="BOOL">
							<descr>Stato forzatura</descr>
						</var>
						<var name="iFv" type="BOOL">
							<descr>Valore forzatura</descr>
						</var>
						<var name="q" type="BOOL">
							<descr>Uscita elaborata</descr>
						</var>
						<var name="appQ" type="BOOL">
							<descr>Appoggio per conteggio n. start (RE)</descr>
						</var>
						<var name="appCk1s" type="BOOL">
							<descr>Appoggio per conteggio Ton (RE ck1s)</descr>
						</var>
						<var name="tmsRun" type="UDINT">
							<descr>Cont.re secondi uscita alta</descr>
						</var>
						<var name="cntStart" type="UDINT">
							<descr>Cont.re n. accensioni</descr>
						</var>
					</vars>
					<iecDeclaration active="FALSE"/>
				</struct>
				<struct name="t_bitCfgAl" version="1.0.0" excludeFromBuild="FALSE" excludeFromBuildIfNotDef="">
					<title>Bit per configurazione allarmi</title>
					<vars>
						<var name="reqd" type="BOOL">
							<descr>stato richiesto non in allarme</descr>
						</var>
						<var name="rstMan" type="BOOL">
							<descr>richiede reset manuale</descr>
						</var>
						<var name="audible" type="BOOL">
							<descr>attiva cicalino</descr>
						</var>
						<var name="active" type="BOOL">
							<descr>da elaborare</descr>
						</var>
						<var name="loPri" type="BOOL">
							<descr>bassa priorità</descr>
						</var>
						<var name="blind" type="BOOL">
							<descr>non luminoso</descr>
						</var>
						<var name="input" type="BOOL">
							<descr>ingresso da controllare</descr>
						</var>
						<var name="live" type="BOOL">
							<descr>attualmente attivo (in allarme)</descr>
						</var>
						<var name="liveRe" type="BOOL"/>
						<var name="mem" type="BOOL">
							<descr>richiede reset</descr>
						</var>
						<var name="piuPiu" type="BOOL">
							<descr>uscita cicalino</descr>
						</var>
					</vars>
					<iecDeclaration active="FALSE"/>
				</struct>
				<struct name="t_alStr" version="1.0.0" excludeFromBuild="FALSE" excludeFromBuildIfNotDef="">
					<title>Struttura bit allarme</title>
					<vars>
						<var name="b" type="t_bitCfgAl">
							<descr>bit di configurazione allarme</descr>
						</var>
						<var name="ph" type="t_ph">
							<descr>fase (stato) in cui si trova l'allarme</descr>
						</var>
						<var name="elapsed_m" type="UDINT">
							<descr>tempo totale allarme attivo</descr>
						</var>
						<var name="count" type="UDINT">
							<descr>conteggio interventi allarme</descr>
						</var>
						<var name="insTmmTrig" type="UDINT"/>
						<var name="insTmmSp" type="UINT">
							<descr>Tempo [mS] insensibilità</descr>
						</var>
					</vars>
					<iecDeclaration active="FALSE"/>
				</struct>
				<struct name="t_db45_allIst" version="1.0.0" excludeFromBuild="FALSE" excludeFromBuildIfNotDef="">
					<title>Istanze allarmi</title>
					<vars>
						<var name="SIaTUTTONOK" type="BOOL">
							<descr>Allarme ausiliari non inseriti</descr>
						</var>
						<var name="TSaSONDCALD" type="BOOL">
							<descr>Allarme parità sonde alte</descr>
						</var>
						<var name="TSaHIGHTEMP" type="BOOL">
							<descr>Warning alta temperatura</descr>
						</var>
						<var name="TSaOVERTEMP" type="BOOL">
							<descr>Allarme alta temperatura</descr>
						</var>
						<var name="TOaACCEFALL" type="BOOL">
							<descr>Allarme accensione fallita</descr>
						</var>
						<var name="TOaMANCFIAM" type="BOOL">
							<descr>Allarme spegnimento fiamma</descr>
						</var>
						<var name="SNaMANCPELL" type="BOOL">
							<descr>Allarme mancanza pellet</descr>
						</var>
						<var name="TTaFUMICALD" type="BOOL">
							<descr>Allarme fumi surriscaldati</descr>
						</var>
						<var name="TTaFUMIFRED" type="BOOL">
							<descr>Allarme fumi troppo freddi</descr>
						</var>
						<var name="TSaTEMPCALD" type="BOOL">
							<descr>Allarme surriscaldamento caldaia</descr>
						</var>
						<var name="TSaCHEKFIAM" type="BOOL">
							<descr>Allarme sensore fiamma</descr>
						</var>
						<var name="TSwPULICENE" type="BOOL">
							<descr>Avviso svuotamento cenere</descr>
						</var>
						<var name="TSwPULICALD" type="BOOL">
							<descr>Avviso pulizia caldaia/camino</descr>
						</var>
						<var name="WDaMBPCSERV" type="BOOL">
							<descr>Allarme watch dog comunicazione server</descr>
						</var>
						<var name="WDaMBMODRAD" type="BOOL">
							<descr>Allarme watch dog comunicazione mod. radio</descr>
						</var>
						<var name="TSaSYSTNRDY" type="BOOL">
							<descr>Allarme sistema non pronto ad erogare</descr>
						</var>
						<var name="ack" type="BOOL">
							<descr>Riconoscimento allarme</descr>
						</var>
						<var name="ackOld" type="BOOL">
							<descr>App. Riconoscimento allarme</descr>
						</var>
						<var name="reset" type="BOOL">
							<descr>Reset allarme</descr>
						</var>
						<var name="resetOld" type="BOOL">
							<descr>App. Reset allarme</descr>
						</var>
						<var name="flSpiaOn" type="BOOL">
							<descr>Aux. com. spia allarme</descr>
						</var>
						<var name="flSpiaBlink" type="BOOL">
							<descr>Aux. com. spia allarme lampeggiante</descr>
						</var>
						<var name="flSonoro" type="BOOL">
							<descr>Aux. com. allarme acustico</descr>
						</var>
						<var name="ptrAl" type="UINT">
							<descr>Puntatore di servizio</descr>
						</var>
						<var name="a" type="t_alStr" dim0="32">
							<descr>Vettore allarmi</descr>
						</var>
						<var name="SInTUTTONOK" type="INT">
							<descr>Allarme ausiliari non inseriti</descr>
							<initValue>0</initValue>
						</var>
						<var name="TSnSONDCALD" type="INT">
							<descr>Allarme sonda in corto alta 1</descr>
							<initValue>1</initValue>
						</var>
						<var name="TSnHIGHTEMP" type="INT">
							<descr>Allarme sonda in corto alta 2</descr>
							<initValue>2</initValue>
						</var>
						<var name="TSnOVERTEMP" type="INT">
							<descr>Allarme sonda in corto bassa 1</descr>
							<initValue>3</initValue>
						</var>
						<var name="TOnACCEFALL" type="INT">
							<descr>Allarme sonda in corto serbatoio</descr>
							<initValue>4</initValue>
						</var>
						<var name="TOnMANCFIAM" type="INT">
							<descr>Allarme parità sonde alte</descr>
							<initValue>5</initValue>
						</var>
						<var name="SNnMANCPELL" type="INT">
							<descr>Allarme parità sonde alte/bassa</descr>
							<initValue>6</initValue>
						</var>
						<var name="TTnFUMICALD" type="INT">
							<descr>Allarme parità sonde temp./press.</descr>
							<initValue>7</initValue>
						</var>
						<var name="TTnFUMIFRED" type="INT">
							<descr>Warning alta temperatura</descr>
							<initValue>8</initValue>
						</var>
						<var name="TSnTEMPCALD" type="INT">
							<descr>Allarme alta temperatura</descr>
							<initValue>9</initValue>
						</var>
						<var name="TSnCHEKFIAM" type="INT">
							<descr>Warning low voltage vehicle box</descr>
							<initValue>10</initValue>
						</var>
						<var name="TSnPULICENE" type="INT">
							<descr>Allarme bilancia non disponibile</descr>
							<initValue>11</initValue>
						</var>
						<var name="TSnPULICALD" type="INT">
							<descr>Allarme vehicle box not reachable</descr>
							<initValue>12</initValue>
						</var>
						<var name="WDnMBPCSERV" type="INT">
							<descr>Allarme watch dog comunicazione server</descr>
							<initValue>25</initValue>
						</var>
						<var name="WDnMBMODRAD" type="INT">
							<descr>Allarme watch dog comunicazione mod. radio</descr>
							<initValue>26</initValue>
						</var>
						<var name="TSnSYSTNRDY" type="INT">
							<descr>Allarme sistema non pronto</descr>
							<initValue>27</initValue>
						</var>
						<var name="phRiposo" type="INT">
							<initValue>0</initValue>
						</var>
						<var name="ph05RitAttivaz" type="INT">
							<initValue>5</initValue>
						</var>
						<var name="ph10AlSonLamp" type="INT">
							<initValue>10</initValue>
						</var>
						<var name="ph20AlLamp" type="INT">
							<initValue>20</initValue>
						</var>
						<var name="ph30Lamp" type="INT">
							<initValue>30</initValue>
						</var>
						<var name="ph35RitRiattivaz" type="INT">
							<initValue>35</initValue>
						</var>
						<var name="ph40AlLampLowP" type="INT">
							<initValue>40</initValue>
						</var>
					</vars>
					<iecDeclaration active="TRUE" valid="TRUE">
						<![CDATA[t_db45_allIst: STRUCT
	SIaTUTTONOK : BOOL;	(* Allarme ausiliari non inseriti *)
	TSaSONDCALD : BOOL;	(* Allarme parità sonde alte *)
	TSaHIGHTEMP : BOOL;	(* Warning alta temperatura *)
	TSaOVERTEMP : BOOL;	(* Allarme alta temperatura *)

	TOaACCEFALL : BOOL;	(* Allarme accensione fallita *)
	TOaMANCFIAM : BOOL;	(* Allarme spegnimento fiamma *)
	SNaMANCPELL : BOOL;	(* Allarme mancanza pellet *)
	TTaFUMICALD : BOOL;	(* Allarme fumi surriscaldati *)

	TTaFUMIFRED : BOOL;	(* Allarme fumi troppo freddi *)
	TSaTEMPCALD : BOOL;	(* Allarme surriscaldamento caldaia *)
	TSaCHEKFIAM : BOOL;	(* Allarme sensore fiamma *)
 	TSwPULICENE : BOOL;	(* Avviso svuotamento cenere *)

 	TSwPULICALD : BOOL;	(* Avviso pulizia caldaia/camino *)
	WDaMBPCSERV : BOOL;	(* Allarme watch dog comunicazione server *)
	WDaMBMODRAD : BOOL;	(* Allarme watch dog comunicazione mod. radio *)
	TSaSYSTNRDY : BOOL;	(* Allarme sistema non pronto ad erogare *)

	ack 				: BOOL;	(* Riconoscimento allarme *)
	ackOld 		: BOOL;	(* App. Riconoscimento allarme *)
	reset 		: BOOL;	(* Reset allarme *)
	resetOld 	: BOOL;	(* App. Reset allarme *)
	flSpiaOn 	: BOOL;	(* Aux. com. spia allarme *)
	flSpiaBlink : BOOL;	(* Aux. com. spia allarme lampeggiante *)
	flSonoro 	: BOOL;	(* Aux. com. allarme acustico *)
	ptrAl 		: UINT;	(* Puntatore di servizio *)

	a 			: ARRAY[0..31] OF t_alStr;	(* Vettore allarmi *)

	SInTUTTONOK  : INT := 0;	(* Allarme ausiliari non inseriti *)
	TSnSONDCALD  : INT := 1;	(* Allarme sonda in corto alta 1 *)
	TSnHIGHTEMP  : INT := 2;	(* Allarme sonda in corto alta 2 *)
	TSnOVERTEMP  : INT := 3;	(* Allarme sonda in corto bassa 1 *)
		
	TOnACCEFALL  : INT := 4;	(* Allarme sonda in corto serbatoio *)
	TOnMANCFIAM  : INT := 5;	(* Allarme parità sonde alte *)
	SNnMANCPELL  : INT := 6;	(* Allarme parità sonde alte/bassa *)
	TTnFUMICALD  : INT := 7;	(* Allarme parità sonde temp./press. *)
		
	TTnFUMIFRED  : INT := 8;	(* Warning alta temperatura *)
	TSnTEMPCALD  : INT := 9;	(* Allarme alta temperatura *)
	TSnCHEKFIAM  : INT := 10;	(* Warning low voltage vehicle box *)
	TSnPULICENE  : INT := 11;	(* Allarme bilancia non disponibile *)
		
	TSnPULICALD  : INT := 12;	(* Allarme vehicle box not reachable *)
//....
	WDnMBPCSERV : INT := 25;	(* Allarme watch dog comunicazione server *)
	WDnMBMODRAD : INT := 26;	(* Allarme watch dog comunicazione mod. radio *)
	TSnSYSTNRDY : INT := 27;	(* Allarme sistema non pronto *)

	phRiposo 			: INT := 0;
	ph05RitAttivaz 		: INT := 5;
	ph10AlSonLamp 		: INT := 10;
	ph20AlLamp 			: INT := 20;
	ph30Lamp 			: INT := 30;
	ph35RitRiattivaz 	: INT := 35;
	ph40AlLampLowP 		: INT := 40;
END_STRUCT;

]]>
					</iecDeclaration>
				</struct>
				<struct name="t_tara" version="1.0.0" excludeFromBuild="FALSE" excludeFromBuildIfNotDef="">
					<vars>
						<var name="tmist" type="INT">
							<descr>Minimo punti (inizio scala) fixP .01</descr>
							<initValue>0</initValue>
						</var>
						<var name="tmast" type="INT">
							<descr>Massimo punti (fondo scala)  fixP .01</descr>
							<initValue>1000</initValue>
						</var>
						<var name="tmiFlt" type="INT">
							<descr>Minimo punti (inizio scala) fixP .01</descr>
							<initValue>-32768</initValue>
						</var>
						<var name="tmaFlt" type="INT">
							<descr>Massimo punti (fondo scala)  fixP .01</descr>
							<initValue>32767</initValue>
						</var>
						<var name="itmist" type="INT">
							<descr>Minimo ingegneristico (inizio scala) fixP .1</descr>
							<initValue>0</initValue>
						</var>
						<var name="itmast" type="INT">
							<descr>Massimo ingegneristico (fondo scala) fixP .1</descr>
							<initValue>1000</initValue>
						</var>
						<var name="kNuovo" type="INT">
							<descr>0&lt;k&lt;=1 frazione di nuovo valore. K piccolo, molto filtrato,  fixP .001</descr>
							<initValue>250</initValue>
						</var>
						<var name="kInp" type="INT">
							<descr>Fattore scala punti (verso HMI)</descr>
							<initValue>10</initValue>
						</var>
						<var name="kEng" type="INT">
							<descr>Fattore scala ingegneristico (verso HMI)</descr>
							<initValue>10</initValue>
						</var>
						<var name="memAllocDummy" type="INT">
							<descr>Tappo per allineamento allocazione oggetti a ind. x4</descr>
							<initValue>0</initValue>
						</var>
					</vars>
					<iecDeclaration active="TRUE" valid="TRUE">
						<![CDATA[t_tara: STRUCT
	tmist : INT := 0;	(* Minimo punti (inizio scala) fixP .01 *)
	tmast : INT := 1000;	(* Massimo punti (fondo scala)  fixP .01 *)
	tmiFlt : INT := -32768;	(* Minimo punti (inizio scala) fixP .01 *)
	tmaFlt : INT := 32767;	(* Massimo punti (fondo scala)  fixP .01 *)
	itmist : INT := 0;	(* Minimo ingegneristico (inizio scala) fixP .1 *)
	itmast : INT := 1000;	(* Massimo ingegneristico (fondo scala) fixP .1 *)
	kNuovo : INT := 250;	(* 0<k<=1 frazione di nuovo valore. K piccolo, molto filtrato,  fixP .001 *)
	kInp : INT := 10;	(* Fattore scala punti (verso HMI)*)
	kEng : INT := 10;	(* Fattore scala ingegneristico (verso HMI)*)	
	memAllocDummy : INT := 0; (* Tappo per allineamento allocazione oggetti a ind. x4 *)
END_STRUCT;

]]>
					</iecDeclaration>
				</struct>
				<struct name="t_pidStr" version="1.0.0" excludeFromBuild="FALSE" excludeFromBuildIfNotDef="">
					<vars>
						<var name="Enb" type="BOOL">
							<descr>False, azzera Bias, output e Y</descr>
						</var>
						<var name="Reverse" type="BOOL">
							<descr>Vero raffredda(?)</descr>
						</var>
						<var name="SP" type="REAL">
							<descr>Set point (ingegneristico)</descr>
						</var>
						<var name="PV" type="REAL">
							<descr>Process value (ingegneristico)</descr>
						</var>
						<var name="Out" type="REAL">
							<descr>Uscita potenza (percentuale)</descr>
						</var>
						<var name="P" type="REAL">
							<descr>Banda proporzionale (piccola, brusco)</descr>
							<initValue>1.0</initValue>
						</var>
						<var name="I" type="REAL">
							<descr>Tempo integrale (piccolo = potente; 0 escluso)</descr>
						</var>
						<var name="D" type="REAL">
							<descr>Tempo derivativo</descr>
						</var>
						<var name="KD" type="REAL">
							<descr>Costante regolazione (15 default)</descr>
							<initValue>15.0</initValue>
						</var>
						<var name="app_I" type="REAL">
							<descr>Integrale di calcolo; diventa enorme se I=0</descr>
						</var>
						<var name="DT_D" type="REAL">
							<descr>Appoggio calcolo tempo interno</descr>
						</var>
						<var name="DeT" type="REAL">
							<descr>Tempo elaborazione</descr>
							<initValue>0.1</initValue>
						</var>
						<var name="ERR" type="REAL">
							<descr>SP-PV (viceversa per reverse=true)</descr>
						</var>
						<var name="Y" type="REAL">
							<descr>Correzione incrementale derivativa</descr>
						</var>
						<var name="BIAS" type="REAL">
							<descr>Correzione incrementale integrale</descr>
						</var>
					</vars>
					<iecDeclaration active="FALSE"/>
				</struct>
				<struct name="t_pwm" version="1.0.0" excludeFromBuild="FALSE" excludeFromBuildIfNotDef="">
					<vars>
						<var name="Percent" type="REAL">
							<descr>Percentuale di tempo uscita attiva</descr>
						</var>
						<var name="PeriodS" type="REAL">
							<descr>Periodo in secondi del ciclo di comando</descr>
						</var>
						<var name="ph" type="t_ph">
							<descr>Gestore fase PWM</descr>
						</var>
						<var name="tmcOn" type="UINT">
							<descr>appoggio tempo attivazione</descr>
						</var>
						<var name="tmcOff" type="UINT">
							<descr>appoggio tempo spegnimento</descr>
						</var>
						<var name="appOut" type="BOOL">
							<descr>appoggio uscita (interno)</descr>
						</var>
						<var name="Enable" type="BOOL">
							<descr>Abilitazione blocco (falso spegne uscita)</descr>
						</var>
						<var name="Out" type="BOOL">
							<descr>Uscita di comando</descr>
						</var>
					</vars>
					<iecDeclaration active="FALSE"/>
				</struct>
				<struct name="t_aiProc" version="1.0.0" excludeFromBuild="FALSE" excludeFromBuildIfNotDef="">
					<title>PV globali</title>
					<vars>
						<var name="tCaldaia" type="REAL"/>
						<var name="tFumi" type="REAL"/>
						<var name="tMandata" type="REAL"/>
						<var name="tRitorno" type="REAL"/>
						<var name="tEsterna" type="REAL"/>
						<var name="tInterna" type="REAL"/>
						<var name="tAriaComb" type="REAL"/>
						<var name="tCaldaia2" type="REAL"/>
						<var name="pFiamma" type="REAL"/>
					</vars>
					<iecDeclaration active="TRUE" valid="TRUE">
						<![CDATA[t_aiProc: STRUCT
	tCaldaia	: 	REAL;
	tFumi		:	REAL;
	tMandata	:	REAL;
	tRitorno	:	REAL;

	tEsterna	:	REAL;
	tInterna	:	REAL;
	tAriaComb	:	REAL;
	tCaldaia2	:	REAL;
	
	pFiamma		:	REAL;

END_STRUCT;

]]>
					</iecDeclaration>
				</struct>
				<struct name="t_cenTerm" version="1.0.0" excludeFromBuild="FALSE" excludeFromBuildIfNotDef="">
					<title>DB generale banco</title>
					<vars>
						<var name="pv" type="t_aiProc"/>
						<var name="cm" type="t_cmdReq"/>
						<var name="bp" type="t_burner"/>
						<var name="tr" type="t_tRegT"/>
						<var name="gm" type="t_gesMand"/>
						<var name="au" type="t_auxGen"/>
						<var name="bk" type="t_bkCalc"/>
						<var name="al" type="t_db45_allIst"/>
						<var name="ai" type="t_aiCh" dim0="10"/>
					</vars>
					<iecDeclaration active="TRUE" valid="TRUE">
						<![CDATA[t_cenTerm: STRUCT
	pv	: t_aiProc;
	cm	: t_cmdReq;
	bp	: t_burner;
	tr	: t_tRegT;
	gm	: t_gesMand;
	au	: t_auxGen;
	bk	: t_bkCalc;
	al	: t_db45_allIst;
	ai	:	ARRAY[0..9] OF t_aiCh;
	//pippo : t_pwRes;
	//WHRegs : ARRAY[0..15] OF WORD;	(* Holding registers (Write) *)

END_STRUCT;


]]>
					</iecDeclaration>
				</struct>
				<struct name="t_tRegT" version="1.0.0" excludeFromBuild="FALSE" excludeFromBuildIfNotDef="">
					<title>Var. termoregolazione bombola</title>
					<vars>
						<var name="phT" type="t_ph"/>
						<var name="pidRisc" type="t_pidStr"/>
						<var name="pwmRisc" type="t_pwm"/>
						<var name="tcTH1" type="t_soc"/>
						<var name="regPar" type="t_pwrStep"/>
						<var name="spTAlWOvert_c" type="REAL">
							<descr>sp temper. massima avviso</descr>
						</var>
						<var name="spTAlAOvert_c" type="REAL">
							<descr>sp temper. massima allarme</descr>
						</var>
						<var name="spTSoc_C" type="REAL">
							<descr>sp temper. analisi SOC</descr>
						</var>
						<var name="spTmSoc_s" type="REAL">
							<descr>sp tempo analisi SOC</descr>
						</var>
						<var name="flAlWOvert" type="BOOL">
							<descr>Flag warn. sovratemp.</descr>
						</var>
						<var name="flAlAOvert" type="BOOL">
							<descr>Flag all. sovratemp.</descr>
						</var>
						<var name="flSysRdy" type="BOOL">
							<descr>Flag sistema pronto con isteresi</descr>
						</var>
					</vars>
					<iecDeclaration active="TRUE" valid="TRUE">
						<![CDATA[t_tRegT: STRUCT
	phT : t_ph;
	pidRisc : t_pidStr;
	pwmRisc : t_pwm;
	tcTH1 : t_soc;
	regPar	:	t_pwrStep;
	
	spTAlWOvert_c	:	REAL;	(* sp temper. massima avviso *)
	spTAlAOvert_c	:	REAL;	(* sp temper. massima allarme *)
	spTSoc_C : REAL;	(* sp temper. analisi SOC *)
	spTmSoc_s : REAL;	(* sp tempo analisi SOC *)
	flAlWOvert 	: BOOL;	(* Flag warn. sovratemp. *)
	flAlAOvert 	: BOOL;	(* Flag all. sovratemp. *)
	flSysRdy	: BOOL;	(* Flag sistema pronto con isteresi *)
END_STRUCT;

]]>
					</iecDeclaration>
				</struct>
				<struct name="t_soc" version="1.0.0" excludeFromBuild="FALSE" excludeFromBuildIfNotDef="">
					<title>Rilevamento sonda in corto</title>
					<vars>
						<var name="ph" type="t_ph"/>
						<var name="spTmChange" type="REAL"/>
						<var name="spTChange" type="REAL"/>
						<var name="pvPwr" type="REAL"/>
						<var name="pvTCurr" type="REAL"/>
						<var name="oltTCurr" type="REAL"/>
						<var name="soc" type="BOOL"/>
						<var name="socRst" type="BOOL"/>
					</vars>
					<iecDeclaration active="TRUE" valid="TRUE">
						<![CDATA[t_soc: STRUCT
      ph : t_ph;
      spTmChange : REAL;
      spTChange : REAL;
      pvPwr : REAL;
      pvTCurr : REAL;
      oltTCurr : REAL;
      soc : BOOL;
      socRst : BOOL;
END_STRUCT;

]]>
					</iecDeclaration>
				</struct>
				<struct name="t_auxGen" version="1.0.0" excludeFromBuild="FALSE" excludeFromBuildIfNotDef="">
					<title>Variabili generali appWide</title>
					<vars>
						<var name="flAbilSpInit" type="BOOL"/>
						<var name="ptrChCfg" type="INT"/>
						<var name="disWd" type="UINT"/>
						<var name="phSD" type="t_ph"/>
					</vars>
					<iecDeclaration active="TRUE" valid="TRUE">
						<![CDATA[t_auxGen: STRUCT
	flAbilSpInit	: BOOL;
	ptrChCfg	:	INT;
	disWd : UINT;
	phSD	:	t_ph;
END_STRUCT;

]]>
					</iecDeclaration>
				</struct>
				<struct name="t_bkCalc" version="1.0.0" excludeFromBuild="FALSE" excludeFromBuildIfNotDef="">
					<vars>
						<var name="i" type="INT">
							<descr>Auxiliary variable</descr>
						</var>
						<var name="dtfRes" type="BOOL"/>
						<var name="DtLocSec" type="UDINT"/>
						<var name="DtMaxDiff" type="INT">
							<initValue>3</initValue>
						</var>
						<var name="LDTS" type="LDATETIMESTRUCT">
							<descr>Long Date/Time struct</descr>
						</var>
						<var name="dtDisable" type="BOOL"/>
					</vars>
					<iecDeclaration active="TRUE" valid="TRUE">
						<![CDATA[t_bkCalc: STRUCT
	i : INT; (* Auxiliary variable *)
	dtfRes	:	BOOL;
	DtLocSec	: UDINT;
	DtMaxDiff	:	INT	:= 3;
    LDTS : LDATETIMESTRUCT; (* Long Date/Time struct *)
    dtDisable	:	BOOL;

END_STRUCT;

]]>
					</iecDeclaration>
				</struct>
				<struct name="t_pwrStep" version="1.0.0" excludeFromBuild="FALSE" excludeFromBuildIfNotDef="">
					<title>Impostazioni di parametri di livello potenza</title>
					<vars>
						<var name="ventPerc" type="INT">
							<descr>Percentuale ventilazione</descr>
						</var>
						<var name="pelletPerc" type="INT">
							<descr>Percentuale carico pellet</descr>
						</var>
						<var name="tmIn" type="UDINT">
							<descr>Momento d'ingresso in fase</descr>
						</var>
					</vars>
					<iecDeclaration active="TRUE" valid="TRUE">
						<![CDATA[t_pwrStep: STRUCT
	ventPerc : INT;	(* Percentuale ventilazione *)
	pelletPerc : INT;	(* Percentuale carico pellet *)
	tmIn : UDINT;	(* Momento d'ingresso in fase *)
END_STRUCT;

]]>
					</iecDeclaration>
				</struct>
				<struct name="t_burner" version="1.0.0" excludeFromBuild="FALSE" excludeFromBuildIfNotDef="">
					<title>Parametri operativi bruciatore</title>
					<vars>
						<var name="phMaCy" type="t_ph">
							<descr>puntatore fase operativa</descr>
						</var>
						<var name="phFlSt" type="t_ph">
							<descr>puntatore fase operativa</descr>
						</var>
						<var name="phCari" type="t_ph">
							<descr>puntatore fase operativa</descr>
						</var>
						<var name="phRefi" type="t_ph">
							<descr>puntatore fase operativa</descr>
						</var>
						<var name="regPar" type="t_pwrStep" dim0="4">
							<descr>config avviamento</descr>
						</var>
						<var name="phStarting" type="t_pwrStep">
							<descr>config avviamento</descr>
						</var>
						<var name="phLowPwr" type="t_pwrStep">
							<descr>conf. bassa potenza</descr>
						</var>
						<var name="phMidPwr" type="t_pwrStep">
							<descr>conf. media potenza</descr>
						</var>
						<var name="phHighPwr" type="t_pwrStep">
							<descr>conf. alta potenza</descr>
						</var>
						<var name="ventDuty" type="INT">
							<descr>percentuale (inversa) comando ventilazione)</descr>
						</var>
						<var name="tmInitLoad" type="UINT">
							<descr>tempo caricamento iniziale pellet da spento</descr>
						</var>
						<var name="tmRitVent" type="UINT">
							<descr>ritardo avvio ventilazione in avviamento</descr>
						</var>
						<var name="toFlame" type="UINT">
							<descr>allarme mancata accensione (pres. fiamma)</descr>
						</var>
					</vars>
					<iecDeclaration active="TRUE" valid="TRUE">
						<![CDATA[t_burner: STRUCT
	phMaCy		:	t_ph;		(* puntatore fase operativa *)
	phFlSt 		:	t_ph;		(* puntatore fase operativa *)
	phCari 		:	t_ph;		(* puntatore fase operativa *)
	phRefi 		:	t_ph;		(* puntatore fase operativa *)
	regPar 		:	ARRAY[0..3] OF t_pwrStep;	(* config avviamento *)
	phStarting 	:	t_pwrStep;	(* config avviamento *)
	phLowPwr 	:	t_pwrStep;	(* conf. bassa potenza *)
	phMidPwr 	:	t_pwrStep;	(* conf. media potenza *)
	phHighPwr 	:	t_pwrStep;	(* conf. alta potenza *)
	ventDuty	:	INT;		(* percentuale (inversa) comando ventilazione) *)
	tmInitLoad 	:	UINT;		(* tempo caricamento iniziale pellet da spento *)
	tmRitVent 	:	UINT;		(* ritardo avvio ventilazione in avviamento *)
	toFlame 	:	UINT;		(* allarme mancata accensione (pres. fiamma) *)
END_STRUCT;

]]>
					</iecDeclaration>
				</struct>
				<struct name="t_cmdReq" version="1.0.0" excludeFromBuild="FALSE" excludeFromBuildIfNotDef="">
					<title>Comandi per il plc</title>
					<vars>
						<var name="ru0nRisc" type="BOOL"/>
						<var name="ru1nAcs" type="BOOL"/>
						<var name="ma2nCocExt" type="BOOL"/>
						<var name="ma3nCocBru" type="BOOL"/>
						<var name="ma4nResIgn" type="BOOL"/>
						<var name="ma5nPomRis" type="BOOL"/>
						<var name="ma6nPomAcs" type="BOOL"/>
						<var name="ma7nApeVal" type="BOOL"/>
						<var name="ma8nChiVal" type="BOOL"/>
						<var name="ma9nVenBru" type="BOOL"/>
						<var name="xxAxxxxxxx" type="BOOL"/>
						<var name="xxBxxxxxxx" type="BOOL"/>
						<var name="flCdataLog" type="BOOL"/>
						<var name="xxDxxxxxxx" type="BOOL"/>
						<var name="mcStblBurn" type="BOOL"/>
						<var name="mcFNextStp" type="BOOL"/>
					</vars>
					<iecDeclaration active="TRUE" valid="TRUE">
						<![CDATA[t_cmdReq: STRUCT
	ru0nRisc 	:	BOOL;
	ru1nAcs 	:	BOOL;
	ma2nCocExt	:	BOOL;
	ma3nCocBru	:	BOOL;
	
	ma4nResIgn	:	BOOL;
	ma5nPomRis	:	BOOL;
	ma6nPomAcs	:	BOOL;
	ma7nApeVal	:	BOOL;
	
	ma8nChiVal	:	BOOL;
	ma9nVenBru	:	BOOL;
	xxAxxxxxxx	:	BOOL;
	xxBxxxxxxx	:	BOOL;

	flCdataLog	:	BOOL;
	xxDxxxxxxx	:	BOOL;
	mcStblBurn	:	BOOL;
	mcFNextStp	:	BOOL;
END_STRUCT;

]]>
					</iecDeclaration>
				</struct>
				<struct name="t_phHiStep" version="1.0.0" excludeFromBuild="FALSE" excludeFromBuildIfNotDef="">
					<title>elemento di memorizz. info trace dei passi</title>
					<vars>
						<var name="phNo" type="INT"/>
						<var name="lasted" type="UDINT"/>
					</vars>
					<iecDeclaration active="TRUE" valid="TRUE">
						<![CDATA[t_phHiStep: STRUCT
	phNo : INT;
	lasted : UDINT;
END_STRUCT;

]]>
					</iecDeclaration>
				</struct>
				<struct name="t_gesMand" version="1.0.0" excludeFromBuild="FALSE" excludeFromBuildIfNotDef="">
					<vars>
						<var name="i" type="INT">
							<descr>Auxiliary variable</descr>
						</var>
						<var name="ph" type="t_ph"/>
						<var name="tMandReq" type="REAL"/>
						<var name="tmCiclo" type="REAL"/>
						<var name="tMandReqMax" type="REAL"/>
						<var name="errTMand" type="REAL"/>
						<var name="spMaxErr" type="REAL"/>
						<var name="spTHtngPmp" type="REAL"/>
						<var name="spTDhwPump" type="REAL"/>
					</vars>
					<iecDeclaration active="TRUE" valid="TRUE">
						<![CDATA[t_gesMand: STRUCT

	i : INT; (* Auxiliary variable *)
	ph			:	t_ph;	
	tMandReq	:	REAL;
	tmCiclo		:	REAL;
	tMandReqMax	:	REAL;
	errTMand	:	REAL;
	spMaxErr	:	REAL;
	spTHtngPmp	:	REAL;
	spTDhwPump	:	REAL;

END_STRUCT;

]]>
					</iecDeclaration>
				</struct>
			</structs>
			<typedefs/>
			<enums/>
			<subranges/>
			<interfaces/>
		</main>
		<target id="Mps046_XUnified_1_0" name="casaldaiaReboot.tgt" fullXml="false">
			<![CDATA[(* ************************************************************************** *)
(* Project      : PCK033****                                                  *)
(* Programmer   : Massimo Piovera                                             *)
(* ************************************************************************** *)
(* Alias "ELSIST XUnified"                                                    *)
(* -------------------------------------------------------------------------- *)

(* ************************************************************************** *)
(* VARIABLES                                                                  *)
(* ************************************************************************** *)

VAR_GLOBAL
    {G:"Digital inputs"}
    SysDI00             AT %IX0.0 : ARRAY[0..31] OF BOOL;       {IO:"Logic inputs module 00"}
    SysDI01             AT %IX1.0 : ARRAY[0..31] OF BOOL;       {IO:"Logic inputs module 01"}
    SysDI02             AT %IX2.0 : ARRAY[0..31] OF BOOL;       {IO:"Logic inputs module 02"}
    SysDI03             AT %IX3.0 : ARRAY[0..31] OF BOOL;       {IO:"Logic inputs module 03"}
    SysDI04             AT %IX4.0 : ARRAY[0..31] OF BOOL;       {IO:"Logic inputs module 04"}
    SysDI05             AT %IX5.0 : ARRAY[0..31] OF BOOL;       {IO:"Logic inputs module 05"}
    SysDI06             AT %IX6.0 : ARRAY[0..31] OF BOOL;       {IO:"Logic inputs module 06"}
    SysDI07             AT %IX7.0 : ARRAY[0..31] OF BOOL;       {IO:"Logic inputs module 07"}
    SysDI08             AT %IX8.0 : ARRAY[0..31] OF BOOL;       {IO:"Logic inputs module 08"}
    SysDI09             AT %IX9.0 : ARRAY[0..31] OF BOOL;       {IO:"Logic inputs module 09"}
    SysDI10             AT %IX10.0 : ARRAY[0..31] OF BOOL;      {IO:"Logic inputs module 10"}
    SysDI11             AT %IX11.0 : ARRAY[0..31] OF BOOL;      {IO:"Logic inputs module 11"}
    SysDI12             AT %IX12.0 : ARRAY[0..31] OF BOOL;      {IO:"Logic inputs module 12"}
    SysDI13             AT %IX13.0 : ARRAY[0..31] OF BOOL;      {IO:"Logic inputs module 13"}
    SysDI14             AT %IX14.0 : ARRAY[0..31] OF BOOL;      {IO:"Logic inputs module 14"}
    SysDI15             AT %IX15.0 : ARRAY[0..31] OF BOOL;      {IO:"Logic inputs module 15"}

    SysCPUDI            AT %IX255.0 : ARRAY[0..31] OF BOOL;     {IO:"Logic inputs CPU"}

    {G:"Digital outputs"}
    SysDO00             AT %QX0.0 : ARRAY[0..31] OF BOOL;       {IO:"Logic outputs module 00"}
    SysDO01             AT %QX1.0 : ARRAY[0..31] OF BOOL;       {IO:"Logic outputs module 01"}
    SysDO02             AT %QX2.0 : ARRAY[0..31] OF BOOL;       {IO:"Logic outputs module 02"}
    SysDO03             AT %QX3.0 : ARRAY[0..31] OF BOOL;       {IO:"Logic outputs module 03"}
    SysDO04             AT %QX4.0 : ARRAY[0..31] OF BOOL;       {IO:"Logic outputs module 04"}
    SysDO05             AT %QX5.0 : ARRAY[0..31] OF BOOL;       {IO:"Logic outputs module 05"}
    SysDO06             AT %QX6.0 : ARRAY[0..31] OF BOOL;       {IO:"Logic outputs module 06"}
    SysDO07             AT %QX7.0 : ARRAY[0..31] OF BOOL;       {IO:"Logic outputs module 07"}
    SysDO08             AT %QX8.0 : ARRAY[0..31] OF BOOL;       {IO:"Logic outputs module 08"}
    SysDO09             AT %QX9.0 : ARRAY[0..31] OF BOOL;       {IO:"Logic outputs module 09"}
    SysDO10             AT %QX10.0 : ARRAY[0..31] OF BOOL;      {IO:"Logic outputs module 10"}
    SysDO11             AT %QX11.0 : ARRAY[0..31] OF BOOL;      {IO:"Logic outputs module 11"}
    SysDO12             AT %QX12.0 : ARRAY[0..31] OF BOOL;      {IO:"Logic outputs module 12"}
    SysDO13             AT %QX13.0 : ARRAY[0..31] OF BOOL;      {IO:"Logic outputs module 13"}
    SysDO14             AT %QX14.0 : ARRAY[0..31] OF BOOL;      {IO:"Logic outputs module 14"}
    SysDO15             AT %QX15.0 : ARRAY[0..31] OF BOOL;      {IO:"Logic outputs module 15"}

    SysCPUDO            AT %QX255.0 : ARRAY[0..31] OF BOOL;     {IO:"Logic outputs CPU"}
END_VAR
]]>
		</target>
		<targetXML name="casaldaiaReboot.tgtx" fullXml="true">
			<target>
				<resources>
					<resource name="ELS20" processor="ARM9">
						<task id="0" name="Fast" type="cyclic" period="1000" descr="Fast task">
							<constraints minPeriod="100" maxPeriod="10000"/>
						</task>
						<task id="1" name="Slow" type="cyclic" period="10000" descr="Slow task">
							<constraints minPeriod="1000" maxPeriod="100000"/>
						</task>
						<task id="2" name="Boot" type="single" period="0" descr="Boot task"/>
						<task id="3" name="Back" period="0" type="cyclic" descr="Background task"/>
					</resource>
				</resources>
			</target>
		</targetXML>
		<libraries/>
		<libdirectories>
			<libdirectory>C:\Program Files (x86)\Elsist\LogicLab\Libraries\Pck055a030</libdirectory>
		</libdirectories>
		<aux>
			<src fullXml="false" name="ElsistInit.PLC" order="-1" hidden="true">
				<![CDATA[
(* XUnified library init *)
PROGRAM $$ElsistInit WITH Boot;
PROGRAM $$ElsistInit

{ HIDDEN:ON }

VAR
dummy : BOOL;
END_VAR

{ CODE:ST }
dummy:=XUnifiedLibInit(TRUE);
END_PROGRAM

]]>
			</src>
			<src fullXml="false" name="HMIsManager.PLC" order="0" hidden="true">
				<![CDATA[]]>
			</src>
		</aux>
		<workspace>
			<root name="casaldaiaReboot" nextID="63309">
				<folder name="Programs" id="1">
					<folder name="Ciclo" id="26149">
						<Pou name="aiRd" id="4246"/>
						<Pou name="logiGen" id="14286"/>
						<Pou name="diRd" id="9761"/>
						<Pou name="doWr" id="4661"/>
						<Pou name="bkCalc" id="20748"/>
						<Pou name="gesAllIst" id="12239"/>
						<Pou name="tarana" id="12233"/>
						<Pou name="gesLamp" id="47302"/>
						<Pou name="mainCycle" id="52775"/>
						<Pou name="flameStatus" id="52818"/>
						<Pou name="gesVent" id="12066" genHidden="false"/>
						<Pou name="refill" id="57558"/>
						<Pou name="gesMand" id="57905"/>
					</folder>
					<folder name="Aux" id="26150">
						<Pou name="_storico" id="10485"/>
						<Pou name="gesAll" id="12154"/>
						<Pou name="init" id="7062"/>
						<Pou name="ManInit" id="38146"/>
					</folder>
					<folder name="Comunicazione" id="29145">
						<Pou name="gesCom2plc" id="11845"/>
						<Pou name="gesCom2hmi" id="8792"/>
						<Pou name="mbMasterRtu" id="48212"/>
						<Pou name="gesMqtt" id="59912"/>
					</folder>
				</folder>
				<folder name="Function blocks" id="3"/>
				<folder name="Functions" id="4">
					<Pou name="ptSet" id="18303"/>
					<Pou name="ptTm" id="18310"/>
					<Pou name="ripara" id="24327"/>
					<Pou name="fPid" id="25594"/>
					<Pou name="fPwm" id="26151"/>
					<Pou name="boolToUdint" id="28141"/>
					<Pou name="getPercErog" id="29060"/>
					<Pou name="fSoc" id="31266"/>
					<Pou name="intToBoolArr" id="54398"/>
					<Pou name="boolArrToInt" id="54399"/>
					<Pou name="pwrMgr" id="57021"/>
				</folder>
				<folder name="Structures" id="5">
					<folder name="Globali" id="30807">
						<Definition name="t_cenTerm" id="30775"/>
					</folder>
					<folder name="Funzionali" id="30808">
						<Definition name="t_db45_allIst" id="12145"/>
						<Definition name="t_aiProc" id="30774"/>
						<Definition name="t_dev" id="8"/>
						<Definition name="t_tRegT" id="30824"/>
						<Definition name="t_burner" id="52593"/>
					</folder>
					<folder name="Base" id="30809">
						<Definition name="t_aiCh" id="7"/>
						<Definition name="t_alStr" id="12144"/>
						<Definition name="t_bitCfgAl" id="12143"/>
						<Definition name="t_ph" id="6"/>
						<Definition name="t_pidStr" id="25611"/>
						<Definition name="t_pwm" id="26154"/>
						<Definition name="t_tara" id="12178"/>
						<Definition name="t_soc" id="31265"/>
						<Definition name="t_auxGen" id="38216"/>
						<Definition name="t_bkCalc" id="42439"/>
						<Definition name="t_pwrStep" id="52592"/>
						<Definition name="t_cmdReq" id="52793"/>
						<Definition name="t_phHiStep" id="53228"/>
						<Definition name="t_gesMand" id="57906"/>
					</folder>
				</folder>
				<folder name="Variables" id="2070">
					<folder name="ordinarie" id="29143">
						<GlobalVars name="vRt2hmi" id="4129"/>
						<GlobalVars name="vRt2plc" id="4130"/>
						<GlobalVars name="vGlobal" id="4244"/>
						<GlobalVars name="vInputs" id="3434"/>
						<GlobalVars name="vOutputs" id="2071"/>
						<GlobalVars name="_vEmulator" id="29476"/>
					</folder>
					<folder name="costanti" id="29144">
						<GlobalVars name="kAi" id="24334"/>
						<GlobalVars name="kAlm" id="30875"/>
						<GlobalVars name="kPhMainCycle" id="52601"/>
						<GlobalVars name="kPhFlameStatus" id="52794"/>
						<GlobalVars name="kPhCaricoP" id="57417"/>
						<GlobalVars name="kPhRefill" id="57560"/>
						<GlobalVars name="kPhGesMand" id="57907"/>
					</folder>
				</folder>
			</root>
		</workspace>
	</sources>
	<codegen crossReference="true" crossReferenceOptions="0x3000001D" listing="true" unusedObjs="true" saveEXPFile="false" saveEXPFileLibraries="false" saveTargetFiles="false" warningEnable="true" symMap="true" checkIndexType="true" waitExtension="false" allocateUnusedVariables="false" checkArrayBounds="true" checkDivisionByZero="true" checkPointers="0" checkReferences="false" checkInterfaces="false" ioVarsAsReferences="true" customTargetBINFileName="PlcCode0.bin" customTargetTSCFileName="PlcSource0.bin" customTargetTDSFileName="PlcDebug0.bin" generateCustomFilesName="true" initFunVarsWithZero="false" enablePreprocessDirectives="false">
		<disabledWarnings>
			<warning>S1300</warning>
			<warning>P2073</warning>
		</disabledWarnings>
		<applicationDataBlocks/>
	</codegen>
	<debug watchRefresh="20" watchVarRefresh="0" watchMaxArray="20" autoSaveWatchList="true" watchFBLocalVars="false"/>
	<editor useOldGridSize="false"/>
	<userDef>
		<release/>
		<author/>
		<note/>
		<version/>
		<password disabled="true"/>
	</userDef>
	<downloadSequence sourceCode="beforeDisconnection" debugSymbols="onPLCApplicationDownload"/>
	<commands>
		<postbuild/>
		<postdown/>
		<predown/>
	</commands>
	<resources>
		<configuration template="LogicLab.pct" version="1">
			<data protocol="root">
				<project_config nextID="0">
					<datacomment/>
				</project_config>
				<Mps046_XUnified_1_0 template="Elsist\Plc\Mps046_XUnified_1_0.pct" version="1" name="SlimLine Mps046B XUnified" caption="SlimLine Mps046B XUnified">
					<config>
						<elsist_hmis/>
					</config>
				</Mps046_XUnified_1_0>
			</data>
		</configuration>
	</resources>
</plcProject>